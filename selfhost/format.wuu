fn format(source: String) -> String {
    let tokens = lex_tokens(source);
    let result = parse_module(tokens, "");
    return pair_left(result);
}

fn format_ast(ast: String) -> String {
    return format_module_ast(ast, "");
}

fn parse_module(tokens: String, indent: String) -> String {
    if __str_is_empty(tokens) {
        return pair("", tokens);
    }

    let item_pair = parse_item(tokens, indent);
    let item_text = pair_left(item_pair);
    let rest_tokens = pair_right(item_pair);
    if __str_is_empty(rest_tokens) {
        return pair(item_text, rest_tokens);
    }

    let next_pair = parse_module(rest_tokens, indent);
    let next_text = pair_left(next_pair);
    let next_rest = pair_right(next_pair);
    let gap = __str_concat(item_text, "\n");
    let joined = __str_concat(gap, next_text);
    return pair(joined, next_rest);
}

fn parse_item(tokens: String, indent: String) -> String {
    if token_is_keyword(tokens, "fn") {
        return parse_fn_like(tokens, indent, "fn");
    }
    if token_is_keyword(tokens, "workflow") {
        return parse_fn_like(tokens, indent, "workflow");
    }
    return pair("", tokens);
}

fn parse_fn_like(tokens: String, indent: String, keyword: String) -> String {
    let after_kw = consume_keyword(tokens, keyword);
    let name_pair = take_ident(after_kw);
    let name = pair_left(name_pair);
    let after_name = pair_right(name_pair);

    let params_pair = parse_params(after_name);
    let params = pair_left(params_pair);
    let after_params = pair_right(params_pair);

    let return_pair = parse_return_type(after_params);
    let return_text = pair_left(return_pair);
    let after_return = pair_right(return_pair);

    let effects_pair = parse_effects_decl(after_return, indent);
    let effects_lines = pair_left(effects_pair);
    let after_effects = pair_right(effects_pair);

    let contracts_pair = parse_contracts(after_effects, indent);
    let contract_lines = pair_left(contracts_pair);
    let after_contracts = pair_right(contracts_pair);

    let block_pair = parse_block(after_contracts, indent);
    let block_text = pair_left(block_pair);
    let after_block = pair_right(block_pair);

    let signature = format_signature(keyword, name, params, return_text);
    let header = line(indent, signature);

    let with_effects = __str_concat(header, effects_lines);
    let with_contracts = __str_concat(with_effects, contract_lines);
    let full_text = __str_concat(with_contracts, block_text);
    return pair(full_text, after_block);
}

fn format_signature(keyword: String, name: String, params: String, ret: String) -> String {
    let base = __str_concat(keyword, " ");
    let base = __str_concat(base, name);
    let base = __str_concat(base, "(");
    let base = __str_concat(base, params);
    let base = __str_concat(base, ")");
    return __str_concat(base, ret);
}

fn parse_params(tokens: String) -> String {
    let after_open = consume_punct(tokens, "(");
    if token_is_punct(after_open, ")") {
        let rest = consume_punct(after_open, ")");
        return pair("", rest);
    }

    let first_pair = parse_param(after_open);
    let first = pair_left(first_pair);
    let rest = pair_right(first_pair);
    return parse_params_tail(first, rest);
}

fn parse_params_tail(current: String, tokens: String) -> String {
    if token_is_punct(tokens, ",") {
        let after_comma = token_rest(tokens);
        if token_is_punct(after_comma, ")") {
            let rest = consume_punct(after_comma, ")");
            return pair(current, rest);
        }
        let next_pair = parse_param(after_comma);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let combined = __str_concat(current, ", ");
        let combined = __str_concat(combined, next);
        return parse_params_tail(combined, rest);
    }
    let rest = consume_punct(tokens, ")");
    return pair(current, rest);
}

fn parse_param(tokens: String) -> String {
    let name_pair = take_ident(tokens);
    let name = pair_left(name_pair);
    let after_name = pair_right(name_pair);
    let after_colon = consume_punct(after_name, ":");
    let type_pair = parse_type(after_colon);
    let ty = pair_left(type_pair);
    let rest = pair_right(type_pair);
    let combined = __str_concat(name, ": ");
    let combined = __str_concat(combined, ty);
    return pair(combined, rest);
}

fn parse_return_type(tokens: String) -> String {
    if starts_with_arrow(tokens) {
        let after_dash = consume_punct(tokens, "-");
        let after_arrow = consume_punct(after_dash, ">");
        let type_pair = parse_type(after_arrow);
        let ty = pair_left(type_pair);
        let rest = pair_right(type_pair);
        let ret = __str_concat(" -> ", ty);
        return pair(ret, rest);
    }
    return pair("", tokens);
}

fn starts_with_arrow(tokens: String) -> Bool {
    if token_is_punct(tokens, "-") {
        let rest = token_rest(tokens);
        if token_is_punct(rest, ">") {
            return true;
        }
    }
    return false;
}

fn parse_effects_decl(tokens: String, indent: String) -> String {
    if token_is_keyword(tokens, "effects") {
        let after_kw = consume_keyword(tokens, "effects");
        let after_open = consume_punct(after_kw, "{");
        if token_is_punct(after_open, "}") {
            let rest = consume_punct(after_open, "}");
            let line_text = line(indent, "effects {}");
            return pair(line_text, rest);
        }
        let list_pair = parse_path_list(after_open);
        let list = pair_left(list_pair);
        let after_list = pair_right(list_pair);
        let rest = consume_punct(after_list, "}");
        let line_text = __str_concat("effects { ", list);
        let line_text = __str_concat(line_text, " }");
        let line_text = line(indent, line_text);
        return pair(line_text, rest);
    }

    if token_is_keyword(tokens, "requires") {
        let after_kw = consume_keyword(tokens, "requires");
        let after_open = consume_punct(after_kw, "{");
        if token_is_punct(after_open, "}") {
            let rest = consume_punct(after_open, "}");
            let line_text = line(indent, "requires {}");
            return pair(line_text, rest);
        }
        let list_pair = parse_require_list(after_open);
        let list = pair_left(list_pair);
        let after_list = pair_right(list_pair);
        let rest = consume_punct(after_list, "}");
        let line_text = __str_concat("requires { ", list);
        let line_text = __str_concat(line_text, " }");
        let line_text = line(indent, line_text);
        return pair(line_text, rest);
    }

    return pair("", tokens);
}

fn parse_path_list(tokens: String) -> String {
    let path_pair = parse_path(tokens);
    let path = pair_left(path_pair);
    let rest = pair_right(path_pair);
    if token_is_punct(rest, ",") {
        let after_comma = token_rest(rest);
        if token_is_punct(after_comma, "}") {
            return pair(path, after_comma);
        }
        let tail_pair = parse_path_list(after_comma);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        let combined = __str_concat(path, ", ");
        let combined = __str_concat(combined, tail);
        return pair(combined, rest2);
    }
    return pair(path, rest);
}

fn parse_require_list(tokens: String) -> String {
    let left_pair = take_ident(tokens);
    let left = pair_left(left_pair);
    let after_left = pair_right(left_pair);
    let after_colon = consume_punct(after_left, ":");
    let right_pair = take_ident(after_colon);
    let right = pair_left(right_pair);
    let rest = pair_right(right_pair);
    let combined = __str_concat(left, ":");
    let combined = __str_concat(combined, right);
    if token_is_punct(rest, ",") {
        let after_comma = token_rest(rest);
        if token_is_punct(after_comma, "}") {
            return pair(combined, after_comma);
        }
        let tail_pair = parse_require_list(after_comma);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        let full = __str_concat(combined, ", ");
        let full = __str_concat(full, tail);
        return pair(full, rest2);
    }
    return pair(combined, rest);
}

fn parse_contracts(tokens: String, indent: String) -> String {
    if token_is_keyword(tokens, "pre") {
        return parse_contract(tokens, indent, "pre");
    }
    if token_is_keyword(tokens, "post") {
        return parse_contract(tokens, indent, "post");
    }
    if token_is_keyword(tokens, "invariant") {
        return parse_contract(tokens, indent, "invariant");
    }
    return pair("", tokens);
}

fn parse_contract(tokens: String, indent: String, keyword: String) -> String {
    let after_kw = consume_keyword(tokens, keyword);
    let after_colon = consume_punct(after_kw, ":");
    let expr_pair = parse_expr(after_colon);
    let expr = pair_left(expr_pair);
    let rest = pair_right(expr_pair);
    let line_text = __str_concat(keyword, ": ");
    let line_text = __str_concat(line_text, expr);
    let line_text = line(indent, line_text);

    let tail_pair = parse_contracts(rest, indent);
    let tail_text = pair_left(tail_pair);
    let tail_rest = pair_right(tail_pair);

    let combined = __str_concat(line_text, tail_text);
    return pair(combined, tail_rest);
}

fn parse_block(tokens: String, indent: String) -> String {
    let after_open = consume_punct(tokens, "{");
    let open_line = line(indent, "{");
    let inner = indent_more(indent);

    let stmt_pair = parse_stmt_list(after_open, inner);
    let stmts = pair_left(stmt_pair);
    let rest = pair_right(stmt_pair);

    let after_close = consume_punct(rest, "}");
    let close_line = line(indent, "}");
    let full = __str_concat(open_line, stmts);
    let full = __str_concat(full, close_line);
    return pair(full, after_close);
}

fn parse_stmt_list(tokens: String, indent: String) -> String {
    if token_is_punct(tokens, "}") {
        return pair("", tokens);
    }
    let stmt_pair = parse_stmt(tokens, indent);
    let stmt_text = pair_left(stmt_pair);
    let rest = pair_right(stmt_pair);

    let tail_pair = parse_stmt_list(rest, indent);
    let tail_text = pair_left(tail_pair);
    let tail_rest = pair_right(tail_pair);

    let combined = __str_concat(stmt_text, tail_text);
    return pair(combined, tail_rest);
}

fn parse_stmt(tokens: String, indent: String) -> String {
    if token_is_keyword(tokens, "let") {
        let after_kw = consume_keyword(tokens, "let");
        let name_pair = take_ident(after_kw);
        let name = pair_left(name_pair);
        let after_name = pair_right(name_pair);
        if token_is_punct(after_name, ":") {
            let after_colon = token_rest(after_name);
            let type_pair = parse_type(after_colon);
            let ty = pair_left(type_pair);
            let after_type = pair_right(type_pair);
            let after_eq = consume_punct(after_type, "=");
            let expr_pair = parse_expr(after_eq);
            let expr = pair_left(expr_pair);
            let after_expr = pair_right(expr_pair);
            let rest = consume_punct(after_expr, ";");
            let line_text = __str_concat("let ", name);
            let line_text = __str_concat(line_text, ": ");
            let line_text = __str_concat(line_text, ty);
            let line_text = __str_concat(line_text, " = ");
            let line_text = __str_concat(line_text, expr);
            let line_text = __str_concat(line_text, ";");
            let line_text = line(indent, line_text);
            return pair(line_text, rest);
        }

        let after_eq = consume_punct(after_name, "=");
        let expr_pair = parse_expr(after_eq);
        let expr = pair_left(expr_pair);
        let after_expr = pair_right(expr_pair);
        let rest = consume_punct(after_expr, ";");
        let line_text = __str_concat("let ", name);
        let line_text = __str_concat(line_text, " = ");
        let line_text = __str_concat(line_text, expr);
        let line_text = __str_concat(line_text, ";");
        let line_text = line(indent, line_text);
        return pair(line_text, rest);
    }

    if token_is_keyword(tokens, "return") {
        let after_kw = consume_keyword(tokens, "return");
        if token_is_punct(after_kw, ";") {
            let rest = consume_punct(after_kw, ";");
            let line_text = line(indent, "return;");
            return pair(line_text, rest);
        }
        let expr_pair = parse_expr(after_kw);
        let expr = pair_left(expr_pair);
        let after_expr = pair_right(expr_pair);
        let rest = consume_punct(after_expr, ";");
        let line_text = __str_concat("return ", expr);
        let line_text = __str_concat(line_text, ";");
        let line_text = line(indent, line_text);
        return pair(line_text, rest);
    }

    if token_is_keyword(tokens, "if") {
        let after_kw = consume_keyword(tokens, "if");
        let expr_pair = parse_expr(after_kw);
        let expr = pair_left(expr_pair);
        let after_expr = pair_right(expr_pair);
        let line_text = __str_concat("if ", expr);
        let line_text = line(indent, line_text);

        let then_pair = parse_block(after_expr, indent);
        let then_text = pair_left(then_pair);
        let after_then = pair_right(then_pair);

        if token_is_keyword(after_then, "else") {
            let after_else = consume_keyword(after_then, "else");
            let else_line = line(indent, "else");
            let else_pair = parse_block(after_else, indent);
            let else_text = pair_left(else_pair);
            let after_else_block = pair_right(else_pair);
            let combined = __str_concat(line_text, then_text);
            let combined = __str_concat(combined, else_line);
            let combined = __str_concat(combined, else_text);
            return pair(combined, after_else_block);
        }

        let combined = __str_concat(line_text, then_text);
        return pair(combined, after_then);
    }

    if token_is_keyword(tokens, "loop") {
        let after_kw = consume_keyword(tokens, "loop");
        let header = line(indent, "loop");
        let body_pair = parse_block(after_kw, indent);
        let body = pair_left(body_pair);
        let rest = pair_right(body_pair);
        let combined = __str_concat(header, body);
        return pair(combined, rest);
    }

    if token_is_keyword(tokens, "step") {
        let after_kw = consume_keyword(tokens, "step");
        let label_pair = take_string_literal(after_kw);
        let label = pair_left(label_pair);
        let after_label = pair_right(label_pair);
        let header = __str_concat("step ", label);
        let header = line(indent, header);
        let body_pair = parse_block(after_label, indent);
        let body = pair_left(body_pair);
        let rest = pair_right(body_pair);
        let combined = __str_concat(header, body);
        return pair(combined, rest);
    }

    let expr_pair = parse_expr(tokens);
    let expr = pair_left(expr_pair);
    let after_expr = pair_right(expr_pair);
    let rest = consume_punct(after_expr, ";");
    let line_text = __str_concat(expr, ";");
    let line_text = line(indent, line_text);
    return pair(line_text, rest);
}

fn parse_expr(tokens: String) -> String {
    if token_is_number(tokens) {
        let number_pair = take_number(tokens);
        return number_pair;
    }
    if token_is_string(tokens) {
        let string_pair = take_string_literal(tokens);
        return string_pair;
    }
    if token_is_ident(tokens) {
        let ident_pair = take_ident(tokens);
        let ident = pair_left(ident_pair);
        let rest = pair_right(ident_pair);
        if is_bool_literal(ident, rest) {
            return pair(ident, rest);
        }
        let path_pair = parse_path_tail(ident, rest);
        let path = pair_left(path_pair);
        let after_path = pair_right(path_pair);
        if token_is_punct(after_path, "(") {
            let after_open = consume_punct(after_path, "(");
            let args_pair = parse_call_args(after_open);
            let args = pair_left(args_pair);
            let rest_tokens = pair_right(args_pair);
            let call = __str_concat(path, "(");
            let call = __str_concat(call, args);
            let call = __str_concat(call, ")");
            return pair(call, rest_tokens);
        }
        return pair(path, after_path);
    }
    return pair("", tokens);
}

fn parse_call_args(tokens: String) -> String {
    if token_is_punct(tokens, ")") {
        let rest = consume_punct(tokens, ")");
        return pair("", rest);
    }

    let expr_pair = parse_expr(tokens);
    let expr = pair_left(expr_pair);
    let rest = pair_right(expr_pair);
    return parse_expr_list_tail(expr, rest);
}

fn parse_expr_list_tail(current: String, tokens: String) -> String {
    if token_is_punct(tokens, ",") {
        let after_comma = token_rest(tokens);
        if token_is_punct(after_comma, ")") {
            let rest = consume_punct(after_comma, ")");
            return pair(current, rest);
        }
        let next_pair = parse_expr(after_comma);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let combined = __str_concat(current, ", ");
        let combined = __str_concat(combined, next);
        return parse_expr_list_tail(combined, rest);
    }
    let rest = consume_punct(tokens, ")");
    return pair(current, rest);
}

fn parse_path(tokens: String) -> String {
    let first_pair = take_ident(tokens);
    let first = pair_left(first_pair);
    let rest = pair_right(first_pair);
    return parse_path_tail(first, rest);
}

fn parse_path_tail(current: String, tokens: String) -> String {
    if token_is_punct(tokens, ".") {
        let after_dot = token_rest(tokens);
        let next_pair = take_ident(after_dot);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let combined = __str_concat(current, ".");
        let combined = __str_concat(combined, next);
        return parse_path_tail(combined, rest);
    }
    return pair(current, tokens);
}

fn parse_type(tokens: String) -> String {
    return parse_path(tokens);
}

fn is_bool_literal(text: String, tokens: String) -> Bool {
    if __str_eq(text, "true") {
        if token_is_punct(tokens, ".") {
            return false;
        }
        if token_is_punct(tokens, "(") {
            return false;
        }
        return true;
    }
    if __str_eq(text, "false") {
        if token_is_punct(tokens, ".") {
            return false;
        }
        if token_is_punct(tokens, "(") {
            return false;
        }
        return true;
    }
    return false;
}

fn line(indent: String, text: String) -> String {
    let line = __str_concat(indent, text);
    return __str_concat(line, "\n");
}

fn indent_more(indent: String) -> String {
    return __str_concat(indent, "    ");
}

fn pair(left: String, right: String) -> String {
    let sep = "\n<SEP>\n";
    let combined = __str_concat(left, sep);
    return __str_concat(combined, right);
}

fn pair_left(value: String) -> String {
    return __pair_left(value);
}

fn pair_right(value: String) -> String {
    return __pair_right(value);
}

fn take_until_sep(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    if __str_starts_with(value, "\n<SEP>\n") {
        return "";
    }
    let head = __str_head(value);
    let tail = __str_tail(value);
    let rest = take_until_sep(tail);
    return __str_concat(head, rest);
}

fn drop_until_sep(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    if __str_starts_with(value, "\n<SEP>\n") {
        return __str_strip_prefix(value, "\n<SEP>\n");
    }
    return drop_until_sep(__str_tail(value));
}

fn split_line(value: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, "\n") {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_line(__str_tail(value));
    let line = pair_left(next);
    let rest = pair_right(next);
    let combined = __str_concat(head, line);
    return pair(combined, rest);
}

fn first_line(tokens: String) -> String {
    let split = split_line(tokens);
    return pair_left(split);
}

fn rest_lines(tokens: String) -> String {
    let split = split_line(tokens);
    return pair_right(split);
}

fn token_is_keyword(tokens: String, keyword: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    let expected = __str_concat("Keyword ", keyword);
    return __str_eq(line, expected);
}

fn token_is_ident(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    return __str_starts_with(line, "Ident ");
}

fn token_is_number(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    return __str_starts_with(line, "Number ");
}

fn token_is_string(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    return __str_starts_with(line, "StringLiteral ");
}

fn token_is_punct(tokens: String, ch: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    let expected = __str_concat("Punct ", ch);
    return __str_eq(line, expected);
}

fn token_rest(tokens: String) -> String {
    return rest_lines(tokens);
}

fn take_ident(tokens: String) -> String {
    let line = first_line(tokens);
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "Ident ");
    return pair(text, rest);
}

fn take_number(tokens: String) -> String {
    let line = first_line(tokens);
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "Number ");
    return pair(text, rest);
}

fn take_string_literal(tokens: String) -> String {
    let line = first_line(tokens);
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "StringLiteral ");
    return pair(text, rest);
}

fn consume_keyword(tokens: String, keyword: String) -> String {
    if token_is_keyword(tokens, keyword) {
        return rest_lines(tokens);
    }
    return tokens;
}

fn consume_punct(tokens: String, ch: String) -> String {
    if token_is_punct(tokens, ch) {
        return rest_lines(tokens);
    }
    return tokens;
}

fn lex_tokens(source: String) -> String {
    return __lex_tokens(source);
}

fn skip_trivia(source: String) -> String {
    if __str_is_empty(source) {
        return source;
    }

    let whitespace = __str_take_whitespace(source);
    if __str_is_empty(whitespace) {
    } else {
        let rest = __str_strip_prefix(source, whitespace);
        return skip_trivia(rest);
    }

    if __str_starts_with(source, "//") {
        let comment = __str_take_line_comment(source);
        let rest = __str_strip_prefix(source, comment);
        return skip_trivia(rest);
    }

    if __str_starts_with(source, "/*") {
        let comment = __str_take_block_comment(source);
        let rest = __str_strip_prefix(source, comment);
        return skip_trivia(rest);
    }

    return source;
}

fn make_token_line(kind: String, text: String) -> String {
    let escaped = escape(text);
    let prefix = __str_concat(kind, " ");
    return __str_concat(prefix, escaped);
}

fn keyword_or_ident_line(ident: String) -> String {
    let escaped = escape(ident);
    if is_keyword(ident) {
        return __str_concat("Keyword ", escaped);
    }
    return __str_concat("Ident ", escaped);
}

fn is_keyword(text: String) -> Bool {
    if __str_eq(text, "effects") {
        return true;
    }
    if __str_eq(text, "requires") {
        return true;
    }
    if __str_eq(text, "fn") {
        return true;
    }
    if __str_eq(text, "workflow") {
        return true;
    }
    if __str_eq(text, "type") {
        return true;
    }
    if __str_eq(text, "record") {
        return true;
    }
    if __str_eq(text, "enum") {
        return true;
    }
    if __str_eq(text, "let") {
        return true;
    }
    if __str_eq(text, "if") {
        return true;
    }
    if __str_eq(text, "else") {
        return true;
    }
    if __str_eq(text, "match") {
        return true;
    }
    if __str_eq(text, "loop") {
        return true;
    }
    if __str_eq(text, "return") {
        return true;
    }
    if __str_eq(text, "step") {
        return true;
    }
    if __str_eq(text, "pre") {
        return true;
    }
    if __str_eq(text, "post") {
        return true;
    }
    if __str_eq(text, "invariant") {
        return true;
    }
    if __str_eq(text, "unsafe") {
        return true;
    }
    return false;
}

fn join_lines(head: String, tail: String) -> String {
    if __str_is_empty(tail) {
        return head;
    }
    let with_newline = __str_concat(head, "\n");
    return __str_concat(with_newline, tail);
}

fn escape(text: String) -> String {
    if __str_is_empty(text) {
        return "";
    }
    let head = __str_head(text);
    let tail = __str_tail(text);
    let escaped = escape_char(head);
    let rest = escape(tail);
    return __str_concat(escaped, rest);
}

fn escape_char(ch: String) -> String {
    if __str_eq(ch, "\\") {
        return "\\\\";
    }
    if __str_eq(ch, "\n") {
        return "\\n";
    }
    if __str_eq(ch, "\r") {
        return "\\r";
    }
    if __str_eq(ch, "\t") {
        return "\\t";
    }
    return ch;
}

fn format_module_ast(module: String, indent: String) -> String {
    let items = node_payload(module);
    return format_items_ast(items, indent);
}

fn format_items_ast(items: String, indent: String) -> String {
    if list_is_empty(items) {
        return "";
    }
    let head = list_head(items);
    let tail = list_tail(items);
    let head_text = format_item_ast(head, indent);
    if list_is_empty(tail) {
        return head_text;
    }
    if __str_eq(tail, items) {
        return head_text;
    }
    let tail_text = format_items_ast(tail, indent);
    let gap = __str_concat(head_text, "\n");
    return __str_concat(gap, tail_text);
}

fn format_item_ast(item: String, indent: String) -> String {
    let tag = node_tag(item);
    if __str_eq(tag, "ItemFn") {
        return format_fn_like_ast(item, indent, "fn");
    }
    if __str_eq(tag, "ItemWorkflow") {
        return format_fn_like_ast(item, indent, "workflow");
    }
    return "";
}

fn format_fn_like_ast(item: String, indent: String, keyword: String) -> String {
    let payload = node_payload(item);
    let name = ast_left_value(payload);
    let rest1 = ast_right(payload);
    let params = ast_left(rest1);
    let rest2 = ast_right(rest1);
    let ret = ast_left(rest2);
    let rest3 = ast_right(rest2);
    let effects_opt = ast_left(rest3);
    let rest4 = ast_right(rest3);
    let contracts = ast_left(rest4);
    let block = ast_right(rest4);

    let signature = format_signature_ast(keyword, name, params, ret);
    let header = line(indent, signature);

    let effects_lines = format_effects_and_contracts_ast(effects_opt, contracts, indent);
    let block_text = format_block_ast(block, indent);
    let with_effects = __str_concat(header, effects_lines);
    return __str_concat(with_effects, block_text);
}

fn format_signature_ast(keyword: String, name: String, params: String, ret: String) -> String {
    let base = __str_concat(keyword, " ");
    let base = __str_concat(base, name);
    let base = __str_concat(base, "(");
    let params_text = format_params_ast(params);
    let base = __str_concat(base, params_text);
    let base = __str_concat(base, ")");
    let ret_text = format_return_type_ast(ret);
    return __str_concat(base, ret_text);
}

fn format_params_ast(params: String) -> String {
    if list_is_empty(params) {
        return "";
    }
    let head = list_head(params);
    let tail = list_tail(params);
    let head_text = format_param_ast(head);
    if list_is_empty(tail) {
        return head_text;
    }
    if __str_eq(tail, params) {
        return head_text;
    }
    let tail_text = format_params_ast(tail);
    let combined = __str_concat(head_text, ", ");
    return __str_concat(combined, tail_text);
}

fn format_param_ast(param: String) -> String {
    let payload = node_payload(param);
    let name = ast_left_value(payload);
    let ty_opt = ast_right(payload);
    if option_is_none(ty_opt) {
        return name;
    }
    let ty = option_unwrap(ty_opt);
    let ty_text = format_type_ast(ty);
    let combined = __str_concat(name, ": ");
    return __str_concat(combined, ty_text);
}

fn format_return_type_ast(ret: String) -> String {
    if option_is_none(ret) {
        return "";
    }
    let ty = option_unwrap(ret);
    let ty_text = format_type_ast(ty);
    let combined = __str_concat(" -> ", ty_text);
    return combined;
}

fn format_effects_and_contracts_ast(effects_opt: String, contracts: String, indent: String) -> String {
    if option_is_none(effects_opt) {
        return format_contracts_ast(contracts, indent);
    }
    let effect_decl = format_effects_decl_ast(option_unwrap(effects_opt));
    let effect_line = line(indent, effect_decl);
    let contract_lines = format_contracts_ast(contracts, indent);
    return __str_concat(effect_line, contract_lines);
}

fn format_effects_decl_ast(effects_decl: String) -> String {
    let tag = node_tag(effects_decl);
    let payload = node_payload(effects_decl);
    if __str_eq(tag, "Effects") {
        if list_is_empty(payload) {
            return "effects {}";
        }
        let list = format_paths_ast(payload);
        let line_text = __str_concat("effects { ", list);
        return __str_concat(line_text, " }");
    }
    if __str_eq(tag, "Requires") {
        if list_is_empty(payload) {
            return "requires {}";
        }
        let list = format_require_list_ast(payload);
        let line_text = __str_concat("requires { ", list);
        return __str_concat(line_text, " }");
    }
    return "";
}

fn format_require_list_ast(reqs: String) -> String {
    if list_is_empty(reqs) {
        return "";
    }
    let head = list_head(reqs);
    let tail = list_tail(reqs);
    let head_text = format_require_ast(head);
    if list_is_empty(tail) {
        return head_text;
    }
    if __str_eq(tail, reqs) {
        return head_text;
    }
    let tail_text = format_require_list_ast(tail);
    let combined = __str_concat(head_text, ", ");
    return __str_concat(combined, tail_text);
}

fn format_require_ast(req: String) -> String {
    let payload = node_payload(req);
    let left = ast_left_value(payload);
    let right = ast_right_value(payload);
    let combined = __str_concat(left, ":");
    return __str_concat(combined, right);
}

fn format_contracts_ast(contracts: String, indent: String) -> String {
    if list_is_empty(contracts) {
        return "";
    }
    let head = list_head(contracts);
    let tail = list_tail(contracts);
    let head_text = format_contract_ast(head);
    let line_text = line(indent, head_text);
    if __str_eq(tail, contracts) {
        return line_text;
    }
    let tail_text = format_contracts_ast(tail, indent);
    return __str_concat(line_text, tail_text);
}

fn format_contract_ast(contract: String) -> String {
    let payload = node_payload(contract);
    let kind = ast_left_value(payload);
    let expr = ast_right(payload);
    let expr_text = format_expr_ast(expr);
    let line_text = __str_concat(kind, ": ");
    return __str_concat(line_text, expr_text);
}

fn format_block_ast(block: String, indent: String) -> String {
    let open_line = line(indent, "{");
    let inner = indent_more(indent);
    let stmts = node_payload(block);
    let stmt_text = format_stmt_list_ast(stmts, inner);
    let close_line = line(indent, "}");
    let combined = __str_concat(open_line, stmt_text);
    return __str_concat(combined, close_line);
}

fn format_stmt_list_ast(stmts: String, indent: String) -> String {
    if list_is_empty(stmts) {
        return "";
    }
    let head = list_head(stmts);
    let tail = list_tail(stmts);
    let head_text = format_stmt_ast(head, indent);
    if __str_eq(tail, stmts) {
        return head_text;
    }
    let tail_text = format_stmt_list_ast(tail, indent);
    return __str_concat(head_text, tail_text);
}

fn format_stmt_ast(stmt: String, indent: String) -> String {
    let tag = node_tag(stmt);
    if __str_eq(tag, "StmtLet") {
        let payload = node_payload(stmt);
        let name = ast_left_value(payload);
        let rest = ast_right(payload);
        let ty_opt = ast_left(rest);
        let expr = ast_right(rest);
        if option_is_none(ty_opt) {
            let line_text = __str_concat("let ", name);
            let line_text = __str_concat(line_text, " = ");
            let line_text = __str_concat(line_text, format_expr_ast(expr));
            let line_text = __str_concat(line_text, ";");
            return line(indent, line_text);
        }
        let ty = option_unwrap(ty_opt);
        let line_text = __str_concat("let ", name);
        let line_text = __str_concat(line_text, ": ");
        let line_text = __str_concat(line_text, format_type_ast(ty));
        let line_text = __str_concat(line_text, " = ");
        let line_text = __str_concat(line_text, format_expr_ast(expr));
        let line_text = __str_concat(line_text, ";");
        return line(indent, line_text);
    }
    if __str_eq(tag, "StmtReturn") {
        let expr_opt = node_payload(stmt);
        if option_is_none(expr_opt) {
            return line(indent, "return;");
        }
        let expr = option_unwrap(expr_opt);
        let line_text = __str_concat("return ", format_expr_ast(expr));
        let line_text = __str_concat(line_text, ";");
        return line(indent, line_text);
    }
    if __str_eq(tag, "StmtExpr") {
        let expr = node_payload(stmt);
        let line_text = __str_concat(format_expr_ast(expr), ";");
        return line(indent, line_text);
    }
    if __str_eq(tag, "StmtIf") {
        let payload = node_payload(stmt);
        let cond = ast_left(payload);
        let rest = ast_right(payload);
        let then_block = ast_left(rest);
        let else_opt = ast_right(rest);
        let header = __str_concat("if ", format_expr_ast(cond));
        let head_line = line(indent, header);
        let then_text = format_block_ast(then_block, indent);
        if option_is_none(else_opt) {
            return __str_concat(head_line, then_text);
        }
        let else_block = option_unwrap(else_opt);
        let else_line = line(indent, "else");
        let else_text = format_block_ast(else_block, indent);
        let combined = __str_concat(head_line, then_text);
        let combined = __str_concat(combined, else_line);
        return __str_concat(combined, else_text);
    }
    if __str_eq(tag, "StmtLoop") {
        let block = node_payload(stmt);
        let header = line(indent, "loop");
        let body = format_block_ast(block, indent);
        return __str_concat(header, body);
    }
    if __str_eq(tag, "StmtStep") {
        let payload = node_payload(stmt);
        let label = ast_left_value(payload);
        let block = ast_right(payload);
        let header = __str_concat("step ", label);
        let header = line(indent, header);
        let body = format_block_ast(block, indent);
        return __str_concat(header, body);
    }
    return "";
}

fn format_expr_ast(expr: String) -> String {
    let tag = node_tag(expr);
    if __str_eq(tag, "ExprNumber") {
        return ast_unescape(node_payload(expr));
    }
    if __str_eq(tag, "ExprString") {
        return ast_unescape(node_payload(expr));
    }
    if __str_eq(tag, "ExprBool") {
        return ast_unescape(node_payload(expr));
    }
    if __str_eq(tag, "ExprPath") {
        return format_path_ast(node_payload(expr));
    }
    if __str_eq(tag, "ExprCall") {
        let payload = node_payload(expr);
        let path = ast_left(payload);
        let args = ast_right(payload);
        let args_text = format_call_args_ast(args);
        let call = __str_concat(format_path_ast(path), "(");
        let call = __str_concat(call, args_text);
        return __str_concat(call, ")");
    }
    return "";
}

fn format_call_args_ast(args: String) -> String {
    if list_is_empty(args) {
        return "";
    }
    let head = list_head(args);
    let tail = list_tail(args);
    let head_text = format_expr_ast(head);
    if list_is_empty(tail) {
        return head_text;
    }
    if __str_eq(tail, args) {
        return head_text;
    }
    let tail_text = format_call_args_ast(tail);
    let combined = __str_concat(head_text, ", ");
    return __str_concat(combined, tail_text);
}

fn format_type_ast(ty: String) -> String {
    let tag = node_tag(ty);
    if __str_eq(tag, "TypePath") {
        let path = node_payload(ty);
        return format_path_ast(path);
    }
    return "";
}

fn format_path_ast(path: String) -> String {
    return format_path_segments(node_payload(path));
}

fn format_path_segments(segments: String) -> String {
    if list_is_empty(segments) {
        return "";
    }
    let head = ast_unescape(list_head(segments));
    let tail = list_tail(segments);
    if list_is_empty(tail) {
        return head;
    }
    if __str_eq(tail, segments) {
        return head;
    }
    let tail_text = format_path_segments(tail);
    let combined = __str_concat(head, ".");
    return __str_concat(combined, tail_text);
}

fn format_paths_ast(paths: String) -> String {
    if list_is_empty(paths) {
        return "";
    }
    let head = list_head(paths);
    let tail = list_tail(paths);
    let head_text = format_path_ast(head);
    if list_is_empty(tail) {
        return head_text;
    }
    if __str_eq(tail, paths) {
        return head_text;
    }
    let tail_text = format_paths_ast(tail);
    let combined = __str_concat(head_text, ", ");
    return __str_concat(combined, tail_text);
}

fn split_at_char(value: String, ch: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, ch) {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_at_char(__str_tail(value), ch);
    let left = pair_left(next);
    let right = pair_right(next);
    let combined = __str_concat(head, left);
    return pair(combined, right);
}

fn node_tag(node: String) -> String {
    let tag_span = ast_left_value(node);
    let split = split_at_char(tag_span, "@");
    return pair_left(split);
}

fn node_payload(node: String) -> String {
    return ast_right_raw(node);
}

fn ast_norm(value: String) -> String {
    if ast_has_sep(value) {
        return value;
    }
    if ast_has_esc_sep(value) {
        return ast_norm(ast_unescape(value));
    }
    return value;
}

fn ast_has_sep(value: String) -> Bool {
    if __str_is_empty(value) {
        return false;
    }
    if __str_starts_with(value, "\n<AST>\n") {
        return true;
    }
    return ast_has_sep(__str_tail(value));
}

fn ast_has_esc_sep(value: String) -> Bool {
    if __str_is_empty(value) {
        return false;
    }
    if __str_starts_with(value, "\n<AST_ESC>\n") {
        return true;
    }
    return ast_has_esc_sep(__str_tail(value));
}

fn ast_has_esc_esc_sep(value: String) -> Bool {
    if __str_is_empty(value) {
        return false;
    }
    if __str_starts_with(value, "\n<AST_ESC_ESC>\n") {
        return true;
    }
    return ast_has_esc_esc_sep(__str_tail(value));
}

fn list_is_empty(list: String) -> Bool {
    return __str_eq(node_tag(list), "Nil");
}

fn list_head(list: String) -> String {
    let payload = node_payload(list);
    return ast_left(payload);
}

fn list_tail(list: String) -> String {
    let payload = node_payload(list);
    return ast_right(payload);
}

fn option_is_none(option: String) -> Bool {
    return __str_eq(node_tag(option), "None");
}

fn option_unwrap(option: String) -> String {
    return node_payload(option);
}

fn ast_left(value: String) -> String {
    return ast_left_raw(value);
}

fn ast_right(value: String) -> String {
    return ast_right_raw(value);
}

fn ast_left_value(value: String) -> String {
    return ast_unescape(ast_left_raw(value));
}

fn ast_right_value(value: String) -> String {
    return ast_unescape(ast_right_raw(value));
}

fn ast_left_raw(value: String) -> String {
    return __ast_left(value);
}

fn ast_right_raw(value: String) -> String {
    return __ast_right(value);
}

fn ast_escape(value: String) -> String {
    return __ast_escape(value);
}

fn ast_unescape(value: String) -> String {
    return __ast_unescape(value);
}
