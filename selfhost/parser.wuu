fn parse(source: String) -> String {
    let tokens = lex_tokens(source);
    let result = parse_module(tokens);
    let ast = result_left(result);
    let rest = result_right(result);
    return output_pair(ast, rest);
}

fn parse_module(tokens: String) -> String {
    let start_tokens = tokens;
    let items_pair = parse_module_items(tokens, list_nil());
    let items_rev = result_left(items_pair);
    let rest_tokens = result_right(items_pair);
    let items = list_reverse(items_rev);
    let span = span_from_tokens(start_tokens, rest_tokens);
    return result_pair(ast_module(span, items), rest_tokens);
}

fn parse_module_items(tokens: String, acc: String) -> String {
    if __str_is_empty(tokens) {
        return result_pair(acc, tokens);
    }
    let item_pair = parse_item(tokens);
    let item = result_left(item_pair);
    let rest_tokens = result_right(item_pair);
    if __str_eq(rest_tokens, tokens) {
        return result_pair(acc, rest_tokens);
    }
    let acc = list_cons(item, acc);
    return parse_module_items(rest_tokens, acc);
}

fn parse_item(tokens: String) -> String {
    if token_is_keyword(tokens, "fn") {
        return parse_fn_like(tokens, "fn");
    }
    if token_is_keyword(tokens, "workflow") {
        return parse_fn_like(tokens, "workflow");
    }
    return result_pair("", tokens);
}

fn parse_fn_like(tokens: String, keyword: String) -> String {
    let start_tokens = tokens;
    let after_kw = consume_keyword(tokens, keyword);
    let name_pair = take_ident(after_kw);
    let name = pair_left(name_pair);
    let after_name = pair_right(name_pair);

    let params_pair = parse_params(after_name);
    let params = result_left(params_pair);
    let after_params = result_right(params_pair);

    let return_pair = parse_return_type(after_params);
    let return_ty = result_left(return_pair);
    let after_return = result_right(return_pair);

    let effects_pair = parse_effects_decl(after_return);
    let effects_opt = result_left(effects_pair);
    let after_effects = result_right(effects_pair);

    let contracts_pair = parse_contracts(after_effects);
    let contracts = result_left(contracts_pair);
    let after_contracts = result_right(contracts_pair);

    let block_pair = parse_block(after_contracts);
    let block = result_left(block_pair);
    let after_block = result_right(block_pair);
    let span = span_from_tokens(start_tokens, after_block);

    if __str_eq(keyword, "fn") {
        let item = ast_item_fn(span, name, params, return_ty, effects_opt, contracts, block);
        return result_pair(item, after_block);
    }
    let item = ast_item_workflow(span, name, params, return_ty, effects_opt, contracts, block);
    return result_pair(item, after_block);
}

fn parse_params(tokens: String) -> String {
    let after_open = consume_punct(tokens, "(");
    if token_is_punct(after_open, ")") {
        let rest = consume_punct(after_open, ")");
        return result_pair(list_nil(), rest);
    }

    let first_pair = parse_param(after_open);
    let first = result_left(first_pair);
    let rest = result_right(first_pair);
    let tail_pair = parse_params_tail(rest);
    let tail = result_left(tail_pair);
    let rest2 = result_right(tail_pair);
    let list = list_cons(first, tail);
    return result_pair(list, rest2);
}

fn parse_params_tail(tokens: String) -> String {
    if token_is_punct(tokens, ",") {
        let after_comma = token_rest(tokens);
        if token_is_punct(after_comma, ")") {
            let rest = consume_punct(after_comma, ")");
            return result_pair(list_nil(), rest);
        }
        let next_pair = parse_param(after_comma);
        let next = result_left(next_pair);
        let rest = result_right(next_pair);
        let tail_pair = parse_params_tail(rest);
        let tail = result_left(tail_pair);
        let rest2 = result_right(tail_pair);
        let list = list_cons(next, tail);
        return result_pair(list, rest2);
    }
    let rest = consume_punct(tokens, ")");
    return result_pair(list_nil(), rest);
}

fn parse_param(tokens: String) -> String {
    let start_tokens = tokens;
    let name_pair = take_ident(tokens);
    let name = pair_left(name_pair);
    let after_name = pair_right(name_pair);
    if token_is_punct(after_name, ":") {
        let after_colon = consume_punct(after_name, ":");
        let type_pair = parse_type(after_colon);
        let ty = result_left(type_pair);
        let rest = result_right(type_pair);
        let span = span_from_tokens(start_tokens, rest);
        return result_pair(ast_param(span, name, option_some(ty)), rest);
    }
    let span = span_from_tokens(start_tokens, after_name);
    return result_pair(ast_param(span, name, option_none()), after_name);
}

fn parse_return_type(tokens: String) -> String {
    if starts_with_arrow(tokens) {
        let after_dash = consume_punct(tokens, "-");
        let after_arrow = consume_punct(after_dash, ">");
        let type_pair = parse_type(after_arrow);
        let ty = result_left(type_pair);
        let rest = result_right(type_pair);
        return result_pair(option_some(ty), rest);
    }
    return result_pair(option_none(), tokens);
}

fn starts_with_arrow(tokens: String) -> Bool {
    if token_is_punct(tokens, "-") {
        let rest = token_rest(tokens);
        if token_is_punct(rest, ">") {
            return true;
        }
    }
    return false;
}

fn parse_effects_decl(tokens: String) -> String {
    let start_tokens = tokens;
    if token_is_keyword(tokens, "effects") {
        let after_kw = consume_keyword(tokens, "effects");
        let after_open = consume_punct(after_kw, "{");
        if token_is_punct(after_open, "}") {
            let rest = consume_punct(after_open, "}");
            let span = span_from_tokens(start_tokens, rest);
            return result_pair(option_some(ast_effects(span, list_nil())), rest);
        }
        let list_pair = parse_path_list(after_open);
        let list = result_left(list_pair);
        let after_list = result_right(list_pair);
        let rest = consume_punct(after_list, "}");
        let span = span_from_tokens(start_tokens, rest);
        return result_pair(option_some(ast_effects(span, list)), rest);
    }

    if token_is_keyword(tokens, "requires") {
        let after_kw = consume_keyword(tokens, "requires");
        let after_open = consume_punct(after_kw, "{");
        if token_is_punct(after_open, "}") {
            let rest = consume_punct(after_open, "}");
            let span = span_from_tokens(start_tokens, rest);
            return result_pair(option_some(ast_requires(span, list_nil())), rest);
        }
        let list_pair = parse_require_list(after_open);
        let list = result_left(list_pair);
        let after_list = result_right(list_pair);
        let rest = consume_punct(after_list, "}");
        let span = span_from_tokens(start_tokens, rest);
        return result_pair(option_some(ast_requires(span, list)), rest);
    }

    return result_pair(option_none(), tokens);
}

fn parse_path_list(tokens: String) -> String {
    let path_pair = parse_path(tokens);
    let path = result_left(path_pair);
    let rest = result_right(path_pair);
    if token_is_punct(rest, ",") {
        let after_comma = token_rest(rest);
        if token_is_punct(after_comma, "}") {
            return result_pair(list_cons(path, list_nil()), after_comma);
        }
        let tail_pair = parse_path_list(after_comma);
        let tail = result_left(tail_pair);
        let rest2 = result_right(tail_pair);
        return result_pair(list_cons(path, tail), rest2);
    }
    return result_pair(list_cons(path, list_nil()), rest);
}

fn parse_require_list(tokens: String) -> String {
    let start_tokens = tokens;
    let left_pair = take_ident(tokens);
    let left = pair_left(left_pair);
    let after_left = pair_right(left_pair);
    let after_colon = consume_punct(after_left, ":");
    let right_pair = take_ident(after_colon);
    let right = pair_left(right_pair);
    let rest = pair_right(right_pair);
    let span = span_from_tokens(start_tokens, rest);
    let req = ast_require(span, left, right);
    if token_is_punct(rest, ",") {
        let after_comma = token_rest(rest);
        if token_is_punct(after_comma, "}") {
            return result_pair(list_cons(req, list_nil()), after_comma);
        }
        let tail_pair = parse_require_list(after_comma);
        let tail = result_left(tail_pair);
        let rest2 = result_right(tail_pair);
        return result_pair(list_cons(req, tail), rest2);
    }
    return result_pair(list_cons(req, list_nil()), rest);
}

fn parse_contracts(tokens: String) -> String {
    if token_is_keyword(tokens, "pre") {
        return parse_contract(tokens, "pre");
    }
    if token_is_keyword(tokens, "post") {
        return parse_contract(tokens, "post");
    }
    if token_is_keyword(tokens, "invariant") {
        return parse_contract(tokens, "invariant");
    }
    return result_pair(list_nil(), tokens);
}

fn parse_contract(tokens: String, keyword: String) -> String {
    let start_tokens = tokens;
    let after_kw = consume_keyword(tokens, keyword);
    let after_colon = consume_punct(after_kw, ":");
    let expr_pair = parse_expr(after_colon);
    let expr = result_left(expr_pair);
    let rest = result_right(expr_pair);
    let span = span_from_tokens(start_tokens, rest);
    let contract = ast_contract(span, keyword, expr);

    let tail_pair = parse_contracts(rest);
    let tail = result_left(tail_pair);
    let tail_rest = result_right(tail_pair);

    return result_pair(list_cons(contract, tail), tail_rest);
}

fn parse_block(tokens: String) -> String {
    let start_tokens = tokens;
    let after_open = consume_punct(tokens, "{");

    let stmt_pair = parse_stmt_list(after_open);
    let stmts = result_left(stmt_pair);
    let rest = result_right(stmt_pair);

    let after_close = consume_punct(rest, "}");
    let span = span_from_tokens(start_tokens, after_close);
    return result_pair(ast_block(span, stmts), after_close);
}

fn parse_stmt_list(tokens: String) -> String {
    if token_is_punct(tokens, "}") {
        return result_pair(list_nil(), tokens);
    }
    let stmt_pair = parse_stmt(tokens);
    let stmt = result_left(stmt_pair);
    let rest = result_right(stmt_pair);
    if __str_eq(rest, tokens) {
        return result_pair(list_nil(), rest);
    }

    let tail_pair = parse_stmt_list(rest);
    let tail = result_left(tail_pair);
    let tail_rest = result_right(tail_pair);

    return result_pair(list_cons(stmt, tail), tail_rest);
}

fn parse_stmt(tokens: String) -> String {
    let start_tokens = tokens;
    if token_is_keyword(tokens, "let") {
        let after_kw = consume_keyword(tokens, "let");
        let name_pair = take_ident(after_kw);
        let name = pair_left(name_pair);
        let after_name = pair_right(name_pair);
        if token_is_punct(after_name, ":") {
            let after_colon = consume_punct(after_name, ":");
            let type_pair = parse_type(after_colon);
            let ty = result_left(type_pair);
            let after_type = result_right(type_pair);
            let after_eq = consume_punct(after_type, "=");
            let expr_pair = parse_expr(after_eq);
            let expr = result_left(expr_pair);
            let after_expr = result_right(expr_pair);
            let rest = consume_punct(after_expr, ";");
            let span = span_from_tokens(start_tokens, rest);
            let stmt = ast_stmt_let(span, name, option_some(ty), expr);
            return result_pair(stmt, rest);
        }

        let after_eq = consume_punct(after_name, "=");
        let expr_pair = parse_expr(after_eq);
        let expr = result_left(expr_pair);
        let after_expr = result_right(expr_pair);
        let rest = consume_punct(after_expr, ";");
        let span = span_from_tokens(start_tokens, rest);
        let stmt = ast_stmt_let(span, name, option_none(), expr);
        return result_pair(stmt, rest);
    }

    if token_is_keyword(tokens, "return") {
        let after_kw = consume_keyword(tokens, "return");
        if token_is_punct(after_kw, ";") {
            let rest = consume_punct(after_kw, ";");
            let span = span_from_tokens(start_tokens, rest);
            let stmt = ast_stmt_return(span, option_none());
            return result_pair(stmt, rest);
        }
        let expr_pair = parse_expr(after_kw);
        let expr = result_left(expr_pair);
        let after_expr = result_right(expr_pair);
        let rest = consume_punct(after_expr, ";");
        let span = span_from_tokens(start_tokens, rest);
        let stmt = ast_stmt_return(span, option_some(expr));
        return result_pair(stmt, rest);
    }

    if token_is_keyword(tokens, "if") {
        let after_kw = consume_keyword(tokens, "if");
        let expr_pair = parse_expr(after_kw);
        let expr = result_left(expr_pair);
        let after_expr = result_right(expr_pair);

        let then_pair = parse_block(after_expr);
        let then_block = result_left(then_pair);
        let after_then = result_right(then_pair);

        if token_is_keyword(after_then, "else") {
            let after_else = consume_keyword(after_then, "else");
            let else_pair = parse_block(after_else);
            let else_block = result_left(else_pair);
            let after_else_block = result_right(else_pair);
            let span = span_from_tokens(start_tokens, after_else_block);
            let stmt = ast_stmt_if(span, expr, then_block, option_some(else_block));
            return result_pair(stmt, after_else_block);
        }

        let span = span_from_tokens(start_tokens, after_then);
        let stmt = ast_stmt_if(span, expr, then_block, option_none());
        return result_pair(stmt, after_then);
    }

    if token_is_keyword(tokens, "loop") {
        let after_kw = consume_keyword(tokens, "loop");
        let body_pair = parse_block(after_kw);
        let body = result_left(body_pair);
        let rest = result_right(body_pair);
        let span = span_from_tokens(start_tokens, rest);
        let stmt = ast_stmt_loop(span, body);
        return result_pair(stmt, rest);
    }

    if token_is_keyword(tokens, "step") {
        let after_kw = consume_keyword(tokens, "step");
        let label_pair = take_string_literal(after_kw);
        let label = pair_left(label_pair);
        let after_label = pair_right(label_pair);
        let body_pair = parse_block(after_label);
        let body = result_left(body_pair);
        let rest = result_right(body_pair);
        let span = span_from_tokens(start_tokens, rest);
        let stmt = ast_stmt_step(span, label, body);
        return result_pair(stmt, rest);
    }

    let expr_pair = parse_expr(tokens);
    let expr = result_left(expr_pair);
    let after_expr = result_right(expr_pair);
    let rest = consume_punct(after_expr, ";");
    let span = span_from_tokens(start_tokens, rest);
    let stmt = ast_stmt_expr(span, expr);
    return result_pair(stmt, rest);
}

fn parse_expr(tokens: String) -> String {
    let start_tokens = tokens;
    if token_is_number(tokens) {
        let number_pair = take_number(tokens);
        let number = pair_left(number_pair);
        let rest = pair_right(number_pair);
        let span = span_from_tokens(start_tokens, rest);
        return result_pair(ast_expr_number(span, number), rest);
    }
    if token_is_string(tokens) {
        let string_pair = take_string_literal(tokens);
        let value = pair_left(string_pair);
        let rest = pair_right(string_pair);
        let span = span_from_tokens(start_tokens, rest);
        return result_pair(ast_expr_string(span, value), rest);
    }
    if token_is_ident(tokens) {
        let ident_pair = take_ident(tokens);
        let ident = pair_left(ident_pair);
        let rest = pair_right(ident_pair);
        if is_bool_literal(ident, rest) {
            let span = span_from_tokens(start_tokens, rest);
            return result_pair(ast_expr_bool(span, ident), rest);
        }
        let tail_pair = parse_path_tail(rest);
        let tail = result_left(tail_pair);
        let after_path = result_right(tail_pair);
        let segments = list_cons(ident, tail);
        let path_span = span_from_tokens(start_tokens, after_path);
        let path = ast_path(path_span, segments);
        if token_is_punct(after_path, "(") {
            let after_open = consume_punct(after_path, "(");
            let args_pair = parse_call_args(after_open);
            let args = result_left(args_pair);
            let rest_tokens = result_right(args_pair);
            let span = span_from_tokens(start_tokens, rest_tokens);
            let expr = ast_expr_call(span, path, args);
            return result_pair(expr, rest_tokens);
        }
        let span = span_from_tokens(start_tokens, after_path);
        return result_pair(ast_expr_path(span, path), after_path);
    }
    return result_pair("", tokens);
}

fn parse_call_args(tokens: String) -> String {
    if token_is_punct(tokens, ")") {
        let rest = consume_punct(tokens, ")");
        return result_pair(list_nil(), rest);
    }

    let expr_pair = parse_expr(tokens);
    let expr = result_left(expr_pair);
    let rest = result_right(expr_pair);
    let tail_pair = parse_expr_list_tail(rest);
    let tail = result_left(tail_pair);
    let rest2 = result_right(tail_pair);
    let list = list_cons(expr, tail);
    return result_pair(list, rest2);
}

fn parse_expr_list_tail(tokens: String) -> String {
    if token_is_punct(tokens, ",") {
        let after_comma = token_rest(tokens);
        if token_is_punct(after_comma, ")") {
            let rest = consume_punct(after_comma, ")");
            return result_pair(list_nil(), rest);
        }
        let next_pair = parse_expr(after_comma);
        let next = result_left(next_pair);
        let rest = result_right(next_pair);
        let tail_pair = parse_expr_list_tail(rest);
        let tail = result_left(tail_pair);
        let rest2 = result_right(tail_pair);
        let list = list_cons(next, tail);
        return result_pair(list, rest2);
    }
    let rest = consume_punct(tokens, ")");
    return result_pair(list_nil(), rest);
}

fn parse_path(tokens: String) -> String {
    let start_tokens = tokens;
    let first_pair = take_ident(tokens);
    let first = pair_left(first_pair);
    let rest = pair_right(first_pair);
    let tail_pair = parse_path_tail(rest);
    let tail = result_left(tail_pair);
    let rest2 = result_right(tail_pair);
    let segments = list_cons(first, tail);
    let span = span_from_tokens(start_tokens, rest2);
    let path = ast_path(span, segments);
    return result_pair(path, rest2);
}

fn parse_path_tail(tokens: String) -> String {
    if token_is_punct(tokens, ".") {
        let after_dot = token_rest(tokens);
        let next_pair = take_ident(after_dot);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let tail_pair = parse_path_tail(rest);
        let tail = result_left(tail_pair);
        let rest2 = result_right(tail_pair);
        let list = list_cons(next, tail);
        return result_pair(list, rest2);
    }
    return result_pair(list_nil(), tokens);
}

fn parse_type(tokens: String) -> String {
    let start_tokens = tokens;
    let path_pair = parse_path(tokens);
    let path = result_left(path_pair);
    let rest = result_right(path_pair);
    let span = span_from_tokens(start_tokens, rest);
    return result_pair(ast_type_path(span, path), rest);
}

fn is_bool_literal(text: String, tokens: String) -> Bool {
    if __str_eq(text, "true") {
        if token_is_punct(tokens, ".") {
            return false;
        }
        if token_is_punct(tokens, "(") {
            return false;
        }
        return true;
    }
    if __str_eq(text, "false") {
        if token_is_punct(tokens, ".") {
            return false;
        }
        if token_is_punct(tokens, "(") {
            return false;
        }
        return true;
    }
    return false;
}

fn span_zero() -> String {
    return span_text("0", "0");
}

fn span_text(start: String, end: String) -> String {
    let sep = ":";
    let combined = __str_concat(start, sep);
    return __str_concat(combined, end);
}

fn node_raw(tag: String, payload: String) -> String {
    return ast_pair(tag, payload);
}

fn node_with_span(tag: String, payload: String, span: String) -> String {
    let tag_span = __str_concat(tag, "@");
    let tag_span = __str_concat(tag_span, span);
    return ast_pair(tag_span, payload);
}

fn node(tag: String, payload: String) -> String {
    return node_with_span(tag, payload, span_zero());
}

fn split_at_char(value: String, ch: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, ch) {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_at_char(__str_tail(value), ch);
    let left = pair_left(next);
    let right = pair_right(next);
    let combined = __str_concat(head, left);
    return pair(combined, right);
}

fn node_tag(node: String) -> String {
    let tag_span = ast_left(node);
    let split = split_at_char(tag_span, "@");
    return pair_left(split);
}

fn node_payload(node: String) -> String {
    return ast_right_raw(node);
}

fn list_nil() -> String {
    return node("Nil", "");
}

fn list_cons(head: String, tail: String) -> String {
    return node("Cons", ast_pair(head, tail));
}

fn list_is_empty(list: String) -> Bool {
    return __str_eq(node_tag(list), "Nil");
}

fn list_head(list: String) -> String {
    let payload = node_payload(list);
    let head = ast_left_raw(payload);
    return ast_unescape(head);
}

fn list_tail(list: String) -> String {
    let payload = node_payload(list);
    let tail = ast_right_raw(payload);
    return ast_unescape(tail);
}

fn list_reverse(list: String) -> String {
    return list_reverse_acc(list, list_nil());
}

fn list_reverse_acc(list: String, acc: String) -> String {
    if list_is_empty(list) {
        return acc;
    }
    let head = list_head(list);
    let tail = list_tail(list);
    let acc = list_cons(head, acc);
    return list_reverse_acc(tail, acc);
}

fn option_none() -> String {
    return node("None", "");
}

fn option_some(value: String) -> String {
    return node("Some", value);
}

fn option_is_none(option: String) -> Bool {
    return __str_eq(node_tag(option), "None");
}

fn option_unwrap(option: String) -> String {
    let payload = node_payload(option);
    return ast_unescape(payload);
}

fn ast_module(span: String, items: String) -> String {
    return node_with_span("Module", items, span);
}

fn ast_item_fn(span: String, name: String, params: String, ret: String, effects_opt: String, contracts: String, block: String) -> String {
    let payload = ast_pair(name, ast_pair(params, ast_pair(ret, ast_pair(effects_opt, ast_pair(contracts, block)))));
    return node_with_span("ItemFn", payload, span);
}

fn ast_item_workflow(span: String, name: String, params: String, ret: String, effects_opt: String, contracts: String, block: String) -> String {
    let payload = ast_pair(name, ast_pair(params, ast_pair(ret, ast_pair(effects_opt, ast_pair(contracts, block)))));
    return node_with_span("ItemWorkflow", payload, span);
}

fn ast_param(span: String, name: String, ty: String) -> String {
    return node_with_span("Param", ast_pair(name, ty), span);
}

fn ast_effects(span: String, paths: String) -> String {
    return node_with_span("Effects", paths, span);
}

fn ast_requires(span: String, pairs: String) -> String {
    return node_with_span("Requires", pairs, span);
}

fn ast_require(span: String, left: String, right: String) -> String {
    return node_with_span("Require", ast_pair(left, right), span);
}

fn ast_contract(span: String, kind: String, expr: String) -> String {
    return node_with_span("Contract", ast_pair(kind, expr), span);
}

fn ast_block(span: String, stmts: String) -> String {
    return node_with_span("Block", stmts, span);
}

fn ast_stmt_let(span: String, name: String, ty: String, expr: String) -> String {
    return node_with_span("StmtLet", ast_pair(name, ast_pair(ty, expr)), span);
}

fn ast_stmt_return(span: String, expr: String) -> String {
    return node_with_span("StmtReturn", expr, span);
}

fn ast_stmt_expr(span: String, expr: String) -> String {
    return node_with_span("StmtExpr", expr, span);
}

fn ast_stmt_if(span: String, cond: String, then_block: String, else_block: String) -> String {
    return node_with_span("StmtIf", ast_pair(cond, ast_pair(then_block, else_block)), span);
}

fn ast_stmt_loop(span: String, block: String) -> String {
    return node_with_span("StmtLoop", block, span);
}

fn ast_stmt_step(span: String, label: String, block: String) -> String {
    return node_with_span("StmtStep", ast_pair(label, block), span);
}

fn ast_expr_number(span: String, text: String) -> String {
    return node_with_span("ExprNumber", text, span);
}

fn ast_expr_string(span: String, text: String) -> String {
    return node_with_span("ExprString", text, span);
}

fn ast_expr_bool(span: String, text: String) -> String {
    return node_with_span("ExprBool", text, span);
}

fn ast_expr_path(span: String, path: String) -> String {
    return node_with_span("ExprPath", path, span);
}

fn ast_expr_call(span: String, path: String, args: String) -> String {
    return node_with_span("ExprCall", ast_pair(path, args), span);
}

fn ast_type_path(span: String, path: String) -> String {
    return node_with_span("TypePath", path, span);
}

fn ast_path(span: String, segments: String) -> String {
    return node_with_span("Path", segments, span);
}

fn pair(left: String, right: String) -> String {
    let sep = "\n<SEP>\n";
    let combined = __str_concat(left, sep);
    return __str_concat(combined, right);
}

fn split_pair_left(value: String, sep: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    if __str_starts_with(value, sep) {
        return "";
    }
    let head = __str_head(value);
    let rest = __str_tail(value);
    let tail = split_pair_left(rest, sep);
    return __str_concat(head, tail);
}

fn split_pair_right(value: String, sep: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    if __str_starts_with(value, sep) {
        return __str_strip_prefix(value, sep);
    }
    let rest = __str_tail(value);
    return split_pair_right(rest, sep);
}

fn output_pair(left: String, right: String) -> String {
    let sep = "\n<OUT>\n";
    let combined = __str_concat(left, sep);
    return __str_concat(combined, right);
}

fn ast_pair(left: String, right: String) -> String {
    let sep = "\n<AST>\n";
    let safe_left = ast_escape(left);
    let safe_right = ast_escape(right);
    let combined = __str_concat(safe_left, sep);
    return __str_concat(combined, safe_right);
}

fn ast_left(value: String) -> String {
    let left = ast_left_raw(value);
    return ast_unescape(left);
}

fn ast_right(value: String) -> String {
    let right = ast_right_raw(value);
    return ast_unescape(right);
}

fn ast_left_raw(value: String) -> String {
    return __ast_left(value);
}

fn ast_right_raw(value: String) -> String {
    return __ast_right(value);
}

fn ast_escape(value: String) -> String {
    return __ast_escape(value);
}

fn ast_unescape(value: String) -> String {
    return __ast_unescape(value);
}

fn result_pair(left: String, right: String) -> String {
    let sep = "\n<AST>\n";
    let safe_left = ast_escape(left);
    let combined = __str_concat(safe_left, sep);
    return __str_concat(combined, right);
}

fn result_left(value: String) -> String {
    let left = ast_left_raw(value);
    return ast_unescape(left);
}

fn result_right(value: String) -> String {
    return ast_right_raw(value);
}

fn pair_left(value: String) -> String {
    let sep = "\n<SEP>\n";
    return split_pair_left(value, sep);
}

fn pair_right(value: String) -> String {
    let sep = "\n<SEP>\n";
    return split_pair_right(value, sep);
}

fn split_line(value: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let prefixed = __str_concat("//", value);
    let comment = __str_take_line_comment(prefixed);
    let line = __str_strip_prefix(comment, "//");
    let rest = __str_strip_prefix(value, line);
    if __str_starts_with(rest, "\n") {
        let rest = __str_strip_prefix(rest, "\n");
        return pair(line, rest);
    }
    return pair(line, rest);
}

fn first_line(tokens: String) -> String {
    let split = split_line(tokens);
    return pair_left(split);
}

fn rest_lines(tokens: String) -> String {
    let split = split_line(tokens);
    return pair_right(split);
}

fn split_first_space(value: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, " ") {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_first_space(__str_tail(value));
    let left = pair_left(next);
    let right = pair_right(next);
    let combined = __str_concat(head, left);
    return pair(combined, right);
}

fn token_line_core(line: String) -> String {
    let split = split_first_space(line);
    let span_text = pair_left(split);
    let rest = pair_right(split);
    if __str_starts_with(span_text, "@") {
        return rest;
    }
    return line;
}

fn split_colon(value: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, ":") {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_colon(__str_tail(value));
    let left = pair_left(next);
    let right = pair_right(next);
    let combined = __str_concat(head, left);
    return pair(combined, right);
}

fn token_span_text(line: String) -> String {
    let split = split_first_space(line);
    let prefix = pair_left(split);
    if __str_starts_with(prefix, "@") {
        return __str_strip_prefix(prefix, "@");
    }
    return "";
}

fn token_span_start_line(line: String) -> String {
    let span_text = token_span_text(line);
    let split = split_colon(span_text);
    return pair_left(split);
}

fn token_span_end_line(line: String) -> String {
    let span_text = token_span_text(line);
    let split = split_colon(span_text);
    return pair_right(split);
}

fn token_span_start(tokens: String) -> String {
    if __str_is_empty(tokens) {
        return "0";
    }
    return token_span_start_line(first_line(tokens));
}

fn span_end_before(start_tokens: String, end_tokens: String) -> String {
    if __str_is_empty(end_tokens) {
        return token_span_start(start_tokens);
    }
    return token_span_start(end_tokens);
}

fn span_from_tokens(start_tokens: String, end_tokens: String) -> String {
    let start = token_span_start(start_tokens);
    let end = span_end_before(start_tokens, end_tokens);
    return span_text(start, end);
}

fn token_is_keyword(tokens: String, keyword: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = token_line_core(first_line(tokens));
    let expected = __str_concat("Keyword ", keyword);
    return __str_eq(line, expected);
}

fn token_is_ident(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = token_line_core(first_line(tokens));
    return __str_starts_with(line, "Ident ");
}

fn token_is_number(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = token_line_core(first_line(tokens));
    return __str_starts_with(line, "Number ");
}

fn token_is_string(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = token_line_core(first_line(tokens));
    return __str_starts_with(line, "StringLiteral ");
}

fn token_is_punct(tokens: String, ch: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = token_line_core(first_line(tokens));
    let expected = __str_concat("Punct ", ch);
    return __str_eq(line, expected);
}

fn token_rest(tokens: String) -> String {
    return rest_lines(tokens);
}

fn take_ident(tokens: String) -> String {
    let line = token_line_core(first_line(tokens));
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "Ident ");
    return pair(text, rest);
}

fn take_number(tokens: String) -> String {
    let line = token_line_core(first_line(tokens));
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "Number ");
    return pair(text, rest);
}

fn take_string_literal(tokens: String) -> String {
    let line = token_line_core(first_line(tokens));
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "StringLiteral ");
    return pair(text, rest);
}

fn consume_keyword(tokens: String, keyword: String) -> String {
    if token_is_keyword(tokens, keyword) {
        return rest_lines(tokens);
    }
    return tokens;
}

fn consume_punct(tokens: String, ch: String) -> String {
    if token_is_punct(tokens, ch) {
        return rest_lines(tokens);
    }
    return tokens;
}

fn lex_tokens(source: String) -> String {
    return __lex_tokens_spanned(source);
}
