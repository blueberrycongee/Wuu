fn parse(source: String) -> String {
    let tokens = lex_tokens(source);
    let result = parse_module(tokens);
    let ast = pair_left(result);
    let rest = pair_right(result);
    return output_pair(ast, rest);
}

fn parse_module(tokens: String) -> String {
    if __str_is_empty(tokens) {
        return pair(ast_module(list_nil()), tokens);
    }

    let item_pair = parse_item(tokens);
    let item = pair_left(item_pair);
    let rest_tokens = pair_right(item_pair);
    if __str_eq(rest_tokens, tokens) {
        return pair(ast_module(list_nil()), rest_tokens);
    }
    if __str_is_empty(rest_tokens) {
        let items = list_cons(item, list_nil());
        return pair(ast_module(items), rest_tokens);
    }

    let next_pair = parse_module(rest_tokens);
    let next_module = pair_left(next_pair);
    let next_rest = pair_right(next_pair);
    let next_items = module_items(next_module);
    let items = list_cons(item, next_items);
    return pair(ast_module(items), next_rest);
}

fn parse_item(tokens: String) -> String {
    if token_is_keyword(tokens, "fn") {
        return parse_fn_like(tokens, "fn");
    }
    if token_is_keyword(tokens, "workflow") {
        return parse_fn_like(tokens, "workflow");
    }
    return pair("", tokens);
}

fn parse_fn_like(tokens: String, keyword: String) -> String {
    let after_kw = consume_keyword(tokens, keyword);
    let name_pair = take_ident(after_kw);
    let name = pair_left(name_pair);
    let after_name = pair_right(name_pair);

    let params_pair = parse_params(after_name);
    let params = pair_left(params_pair);
    let after_params = pair_right(params_pair);

    let return_pair = parse_return_type(after_params);
    let return_ty = pair_left(return_pair);
    let after_return = pair_right(return_pair);

    let effects_pair = parse_effects_decl(after_return);
    let effects_opt = pair_left(effects_pair);
    let after_effects = pair_right(effects_pair);

    let contracts_pair = parse_contracts(after_effects);
    let contracts = pair_left(contracts_pair);
    let after_contracts = pair_right(contracts_pair);

    let block_pair = parse_block(after_contracts);
    let block = pair_left(block_pair);
    let after_block = pair_right(block_pair);

    if __str_eq(keyword, "fn") {
    let item = ast_item_fn(name, params, return_ty, effects_opt, contracts, block);
        return pair(item, after_block);
    }
    let item = ast_item_workflow(name, params, return_ty, effects_opt, contracts, block);
    return pair(item, after_block);
}

fn parse_params(tokens: String) -> String {
    let after_open = consume_punct(tokens, "(");
    if token_is_punct(after_open, ")") {
        let rest = consume_punct(after_open, ")");
        return pair(list_nil(), rest);
    }

    let first_pair = parse_param(after_open);
    let first = pair_left(first_pair);
    let rest = pair_right(first_pair);
    let tail_pair = parse_params_tail(rest);
    let tail = pair_left(tail_pair);
    let rest2 = pair_right(tail_pair);
    let list = list_cons(first, tail);
    return pair(list, rest2);
}

fn parse_params_tail(tokens: String) -> String {
    if token_is_punct(tokens, ",") {
        let after_comma = token_rest(tokens);
        if token_is_punct(after_comma, ")") {
            let rest = consume_punct(after_comma, ")");
            return pair(list_nil(), rest);
        }
        let next_pair = parse_param(after_comma);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let tail_pair = parse_params_tail(rest);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        let list = list_cons(next, tail);
        return pair(list, rest2);
    }
    let rest = consume_punct(tokens, ")");
    return pair(list_nil(), rest);
}

fn parse_param(tokens: String) -> String {
    let name_pair = take_ident(tokens);
    let name = pair_left(name_pair);
    let after_name = pair_right(name_pair);
    if token_is_punct(after_name, ":") {
        let after_colon = consume_punct(after_name, ":");
        let type_pair = parse_type(after_colon);
        let ty = pair_left(type_pair);
        let rest = pair_right(type_pair);
        return pair(ast_param(name, option_some(ty)), rest);
    }
    return pair(ast_param(name, option_none()), after_name);
}

fn parse_return_type(tokens: String) -> String {
    if starts_with_arrow(tokens) {
        let after_dash = consume_punct(tokens, "-");
        let after_arrow = consume_punct(after_dash, ">");
        let type_pair = parse_type(after_arrow);
        let ty = pair_left(type_pair);
        let rest = pair_right(type_pair);
        return pair(option_some(ty), rest);
    }
    return pair(option_none(), tokens);
}

fn starts_with_arrow(tokens: String) -> Bool {
    if token_is_punct(tokens, "-") {
        let rest = token_rest(tokens);
        if token_is_punct(rest, ">") {
            return true;
        }
    }
    return false;
}

fn parse_effects_decl(tokens: String) -> String {
    if token_is_keyword(tokens, "effects") {
        let after_kw = consume_keyword(tokens, "effects");
        let after_open = consume_punct(after_kw, "{");
        if token_is_punct(after_open, "}") {
            let rest = consume_punct(after_open, "}");
            return pair(option_some(ast_effects(list_nil())), rest);
        }
        let list_pair = parse_path_list(after_open);
        let list = pair_left(list_pair);
        let after_list = pair_right(list_pair);
        let rest = consume_punct(after_list, "}");
        return pair(option_some(ast_effects(list)), rest);
    }

    if token_is_keyword(tokens, "requires") {
        let after_kw = consume_keyword(tokens, "requires");
        let after_open = consume_punct(after_kw, "{");
        if token_is_punct(after_open, "}") {
            let rest = consume_punct(after_open, "}");
            return pair(option_some(ast_requires(list_nil())), rest);
        }
        let list_pair = parse_require_list(after_open);
        let list = pair_left(list_pair);
        let after_list = pair_right(list_pair);
        let rest = consume_punct(after_list, "}");
        return pair(option_some(ast_requires(list)), rest);
    }

    return pair(option_none(), tokens);
}

fn parse_path_list(tokens: String) -> String {
    let path_pair = parse_path(tokens);
    let path = pair_left(path_pair);
    let rest = pair_right(path_pair);
    if token_is_punct(rest, ",") {
        let after_comma = token_rest(rest);
        if token_is_punct(after_comma, "}") {
            return pair(list_cons(path, list_nil()), after_comma);
        }
        let tail_pair = parse_path_list(after_comma);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        return pair(list_cons(path, tail), rest2);
    }
    return pair(list_cons(path, list_nil()), rest);
}

fn parse_require_list(tokens: String) -> String {
    let left_pair = take_ident(tokens);
    let left = pair_left(left_pair);
    let after_left = pair_right(left_pair);
    let after_colon = consume_punct(after_left, ":");
    let right_pair = take_ident(after_colon);
    let right = pair_left(right_pair);
    let rest = pair_right(right_pair);
    let req = ast_require(left, right);
    if token_is_punct(rest, ",") {
        let after_comma = token_rest(rest);
        if token_is_punct(after_comma, "}") {
            return pair(list_cons(req, list_nil()), after_comma);
        }
        let tail_pair = parse_require_list(after_comma);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        return pair(list_cons(req, tail), rest2);
    }
    return pair(list_cons(req, list_nil()), rest);
}

fn parse_contracts(tokens: String) -> String {
    if token_is_keyword(tokens, "pre") {
        return parse_contract(tokens, "pre");
    }
    if token_is_keyword(tokens, "post") {
        return parse_contract(tokens, "post");
    }
    if token_is_keyword(tokens, "invariant") {
        return parse_contract(tokens, "invariant");
    }
    return pair(list_nil(), tokens);
}

fn parse_contract(tokens: String, keyword: String) -> String {
    let after_kw = consume_keyword(tokens, keyword);
    let after_colon = consume_punct(after_kw, ":");
    let expr_pair = parse_expr(after_colon);
    let expr = pair_left(expr_pair);
    let rest = pair_right(expr_pair);
    let contract = ast_contract(keyword, expr);

    let tail_pair = parse_contracts(rest);
    let tail = pair_left(tail_pair);
    let tail_rest = pair_right(tail_pair);

    return pair(list_cons(contract, tail), tail_rest);
}

fn parse_block(tokens: String) -> String {
    let after_open = consume_punct(tokens, "{");

    let stmt_pair = parse_stmt_list(after_open);
    let stmts = pair_left(stmt_pair);
    let rest = pair_right(stmt_pair);

    let after_close = consume_punct(rest, "}");
    return pair(ast_block(stmts), after_close);
}

fn parse_stmt_list(tokens: String) -> String {
    if token_is_punct(tokens, "}") {
        return pair(list_nil(), tokens);
    }
    let stmt_pair = parse_stmt(tokens);
    let stmt = pair_left(stmt_pair);
    let rest = pair_right(stmt_pair);
    if __str_eq(rest, tokens) {
        return pair(list_nil(), rest);
    }

    let tail_pair = parse_stmt_list(rest);
    let tail = pair_left(tail_pair);
    let tail_rest = pair_right(tail_pair);

    return pair(list_cons(stmt, tail), tail_rest);
}

fn parse_stmt(tokens: String) -> String {
    if token_is_keyword(tokens, "let") {
        let after_kw = consume_keyword(tokens, "let");
        let name_pair = take_ident(after_kw);
        let name = pair_left(name_pair);
        let after_name = pair_right(name_pair);
        if token_is_punct(after_name, ":") {
            let after_colon = consume_punct(after_name, ":");
            let type_pair = parse_type(after_colon);
            let ty = pair_left(type_pair);
            let after_type = pair_right(type_pair);
            let after_eq = consume_punct(after_type, "=");
            let expr_pair = parse_expr(after_eq);
            let expr = pair_left(expr_pair);
            let after_expr = pair_right(expr_pair);
            let rest = consume_punct(after_expr, ";");
            let stmt = ast_stmt_let(name, option_some(ty), expr);
            return pair(stmt, rest);
        }

        let after_eq = consume_punct(after_name, "=");
        let expr_pair = parse_expr(after_eq);
        let expr = pair_left(expr_pair);
        let after_expr = pair_right(expr_pair);
        let rest = consume_punct(after_expr, ";");
        let stmt = ast_stmt_let(name, option_none(), expr);
        return pair(stmt, rest);
    }

    if token_is_keyword(tokens, "return") {
        let after_kw = consume_keyword(tokens, "return");
        if token_is_punct(after_kw, ";") {
            let rest = consume_punct(after_kw, ";");
            let stmt = ast_stmt_return(option_none());
            return pair(stmt, rest);
        }
        let expr_pair = parse_expr(after_kw);
        let expr = pair_left(expr_pair);
        let after_expr = pair_right(expr_pair);
        let rest = consume_punct(after_expr, ";");
        let stmt = ast_stmt_return(option_some(expr));
        return pair(stmt, rest);
    }

    if token_is_keyword(tokens, "if") {
        let after_kw = consume_keyword(tokens, "if");
        let expr_pair = parse_expr(after_kw);
        let expr = pair_left(expr_pair);
        let after_expr = pair_right(expr_pair);

        let then_pair = parse_block(after_expr);
        let then_block = pair_left(then_pair);
        let after_then = pair_right(then_pair);

        if token_is_keyword(after_then, "else") {
            let after_else = consume_keyword(after_then, "else");
            let else_pair = parse_block(after_else);
            let else_block = pair_left(else_pair);
            let after_else_block = pair_right(else_pair);
            let stmt = ast_stmt_if(expr, then_block, option_some(else_block));
            return pair(stmt, after_else_block);
        }

        let stmt = ast_stmt_if(expr, then_block, option_none());
        return pair(stmt, after_then);
    }

    if token_is_keyword(tokens, "loop") {
        let after_kw = consume_keyword(tokens, "loop");
        let body_pair = parse_block(after_kw);
        let body = pair_left(body_pair);
        let rest = pair_right(body_pair);
        let stmt = ast_stmt_loop(body);
        return pair(stmt, rest);
    }

    if token_is_keyword(tokens, "step") {
        let after_kw = consume_keyword(tokens, "step");
        let label_pair = take_string_literal(after_kw);
        let label = pair_left(label_pair);
        let after_label = pair_right(label_pair);
        let body_pair = parse_block(after_label);
        let body = pair_left(body_pair);
        let rest = pair_right(body_pair);
        let stmt = ast_stmt_step(label, body);
        return pair(stmt, rest);
    }

    let expr_pair = parse_expr(tokens);
    let expr = pair_left(expr_pair);
    let after_expr = pair_right(expr_pair);
    let rest = consume_punct(after_expr, ";");
    let stmt = ast_stmt_expr(expr);
    return pair(stmt, rest);
}

fn parse_expr(tokens: String) -> String {
    if token_is_number(tokens) {
        let number_pair = take_number(tokens);
        let number = pair_left(number_pair);
        let rest = pair_right(number_pair);
        return pair(ast_expr_number(number), rest);
    }
    if token_is_string(tokens) {
        let string_pair = take_string_literal(tokens);
        let value = pair_left(string_pair);
        let rest = pair_right(string_pair);
        return pair(ast_expr_string(value), rest);
    }
    if token_is_ident(tokens) {
        let ident_pair = take_ident(tokens);
        let ident = pair_left(ident_pair);
        let rest = pair_right(ident_pair);
        if is_bool_literal(ident, rest) {
            return pair(ast_expr_bool(ident), rest);
        }
        let tail_pair = parse_path_tail(rest);
        let tail = pair_left(tail_pair);
        let after_path = pair_right(tail_pair);
        let segments = list_cons(ident, tail);
        let path = ast_path(segments);
        if token_is_punct(after_path, "(") {
            let after_open = consume_punct(after_path, "(");
            let args_pair = parse_call_args(after_open);
            let args = pair_left(args_pair);
            let rest_tokens = pair_right(args_pair);
            let expr = ast_expr_call(path, args);
            return pair(expr, rest_tokens);
        }
        return pair(ast_expr_path(path), after_path);
    }
    return pair("", tokens);
}

fn parse_call_args(tokens: String) -> String {
    if token_is_punct(tokens, ")") {
        let rest = consume_punct(tokens, ")");
        return pair(list_nil(), rest);
    }

    let expr_pair = parse_expr(tokens);
    let expr = pair_left(expr_pair);
    let rest = pair_right(expr_pair);
    let tail_pair = parse_expr_list_tail(rest);
    let tail = pair_left(tail_pair);
    let rest2 = pair_right(tail_pair);
    let list = list_cons(expr, tail);
    return pair(list, rest2);
}

fn parse_expr_list_tail(tokens: String) -> String {
    if token_is_punct(tokens, ",") {
        let after_comma = token_rest(tokens);
        if token_is_punct(after_comma, ")") {
            let rest = consume_punct(after_comma, ")");
            return pair(list_nil(), rest);
        }
        let next_pair = parse_expr(after_comma);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let tail_pair = parse_expr_list_tail(rest);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        let list = list_cons(next, tail);
        return pair(list, rest2);
    }
    let rest = consume_punct(tokens, ")");
    return pair(list_nil(), rest);
}

fn parse_path(tokens: String) -> String {
    let first_pair = take_ident(tokens);
    let first = pair_left(first_pair);
    let rest = pair_right(first_pair);
    let tail_pair = parse_path_tail(rest);
    let tail = pair_left(tail_pair);
    let rest2 = pair_right(tail_pair);
    let segments = list_cons(first, tail);
    let path = ast_path(segments);
    return pair(path, rest2);
}

fn parse_path_tail(tokens: String) -> String {
    if token_is_punct(tokens, ".") {
        let after_dot = token_rest(tokens);
        let next_pair = take_ident(after_dot);
        let next = pair_left(next_pair);
        let rest = pair_right(next_pair);
        let tail_pair = parse_path_tail(rest);
        let tail = pair_left(tail_pair);
        let rest2 = pair_right(tail_pair);
        let list = list_cons(next, tail);
        return pair(list, rest2);
    }
    return pair(list_nil(), tokens);
}

fn parse_type(tokens: String) -> String {
    let path_pair = parse_path(tokens);
    let path = pair_left(path_pair);
    let rest = pair_right(path_pair);
    return pair(ast_type_path(path), rest);
}

fn is_bool_literal(text: String, tokens: String) -> Bool {
    if __str_eq(text, "true") {
        if token_is_punct(tokens, ".") {
            return false;
        }
        if token_is_punct(tokens, "(") {
            return false;
        }
        return true;
    }
    if __str_eq(text, "false") {
        if token_is_punct(tokens, ".") {
            return false;
        }
        if token_is_punct(tokens, "(") {
            return false;
        }
        return true;
    }
    return false;
}

fn module_items(module: String) -> String {
    let payload = node_payload(module);
    return ast_unescape(payload);
}

fn node(tag: String, payload: String) -> String {
    return ast_pair(tag, payload);
}

fn node_tag(node: String) -> String {
    return ast_left(node);
}

fn node_payload(node: String) -> String {
    return ast_right_raw(node);
}

fn list_nil() -> String {
    return node("Nil", "");
}

fn list_cons(head: String, tail: String) -> String {
    return node("Cons", ast_pair(head, tail));
}

fn list_is_empty(list: String) -> Bool {
    return __str_eq(node_tag(list), "Nil");
}

fn list_head(list: String) -> String {
    let payload = node_payload(list);
    let head = ast_left_raw(payload);
    return ast_unescape(head);
}

fn list_tail(list: String) -> String {
    let payload = node_payload(list);
    let tail = ast_right_raw(payload);
    return ast_unescape(tail);
}

fn option_none() -> String {
    return node("None", "");
}

fn option_some(value: String) -> String {
    return node("Some", value);
}

fn option_is_none(option: String) -> Bool {
    return __str_eq(node_tag(option), "None");
}

fn option_unwrap(option: String) -> String {
    let payload = node_payload(option);
    return ast_unescape(payload);
}

fn ast_module(items: String) -> String {
    return node("Module", items);
}

fn ast_item_fn(name: String, params: String, ret: String, effects_opt: String, contracts: String, block: String) -> String {
    let payload = ast_pair(name, ast_pair(params, ast_pair(ret, ast_pair(effects_opt, ast_pair(contracts, block)))));
    return node("ItemFn", payload);
}

fn ast_item_workflow(name: String, params: String, ret: String, effects_opt: String, contracts: String, block: String) -> String {
    let payload = ast_pair(name, ast_pair(params, ast_pair(ret, ast_pair(effects_opt, ast_pair(contracts, block)))));
    return node("ItemWorkflow", payload);
}

fn ast_param(name: String, ty: String) -> String {
    return node("Param", ast_pair(name, ty));
}

fn ast_effects(paths: String) -> String {
    return node("Effects", paths);
}

fn ast_requires(pairs: String) -> String {
    return node("Requires", pairs);
}

fn ast_require(left: String, right: String) -> String {
    return node("Require", ast_pair(left, right));
}

fn ast_contract(kind: String, expr: String) -> String {
    return node("Contract", ast_pair(kind, expr));
}

fn ast_block(stmts: String) -> String {
    return node("Block", stmts);
}

fn ast_stmt_let(name: String, ty: String, expr: String) -> String {
    return node("StmtLet", ast_pair(name, ast_pair(ty, expr)));
}

fn ast_stmt_return(expr: String) -> String {
    return node("StmtReturn", expr);
}

fn ast_stmt_expr(expr: String) -> String {
    return node("StmtExpr", expr);
}

fn ast_stmt_if(cond: String, then_block: String, else_block: String) -> String {
    return node("StmtIf", ast_pair(cond, ast_pair(then_block, else_block)));
}

fn ast_stmt_loop(block: String) -> String {
    return node("StmtLoop", block);
}

fn ast_stmt_step(label: String, block: String) -> String {
    return node("StmtStep", ast_pair(label, block));
}

fn ast_expr_number(text: String) -> String {
    return node("ExprNumber", text);
}

fn ast_expr_string(text: String) -> String {
    return node("ExprString", text);
}

fn ast_expr_bool(text: String) -> String {
    return node("ExprBool", text);
}

fn ast_expr_path(path: String) -> String {
    return node("ExprPath", path);
}

fn ast_expr_call(path: String, args: String) -> String {
    return node("ExprCall", ast_pair(path, args));
}

fn ast_type_path(path: String) -> String {
    return node("TypePath", path);
}

fn ast_path(segments: String) -> String {
    return node("Path", segments);
}

fn pair(left: String, right: String) -> String {
    let sep = "\n<SEP>\n";
    let combined = __str_concat(left, sep);
    return __str_concat(combined, right);
}

fn output_pair(left: String, right: String) -> String {
    let sep = "\n<OUT>\n";
    let combined = __str_concat(left, sep);
    return __str_concat(combined, right);
}

fn ast_pair(left: String, right: String) -> String {
    let sep = "\n<AST>\n";
    let safe_left = ast_escape(left);
    let safe_right = ast_escape(right);
    let combined = __str_concat(safe_left, sep);
    return __str_concat(combined, safe_right);
}

fn ast_left(value: String) -> String {
    let left = ast_left_raw(value);
    return ast_unescape(left);
}

fn ast_right(value: String) -> String {
    let right = ast_right_raw(value);
    return ast_unescape(right);
}

fn ast_left_raw(value: String) -> String {
    return ast_take_until_sep(value);
}

fn ast_right_raw(value: String) -> String {
    return ast_drop_until_sep(value);
}

fn ast_take_until_sep(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    if __str_starts_with(value, "\n<AST>\n") {
        return "";
    }
    let head = __str_head(value);
    let tail = __str_tail(value);
    let rest = ast_take_until_sep(tail);
    return __str_concat(head, rest);
}

fn ast_drop_until_sep(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    if __str_starts_with(value, "\n<AST>\n") {
        return __str_strip_prefix(value, "\n<AST>\n");
    }
    return ast_drop_until_sep(__str_tail(value));
}

fn ast_escape(value: String) -> String {
    return value;
}

fn ast_unescape(value: String) -> String {
    return value;
}

fn pair_left(value: String) -> String {
    return __pair_left(value);
}

fn pair_right(value: String) -> String {
    return __pair_right(value);
}

fn split_line(value: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, "\n") {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_line(__str_tail(value));
    let line = pair_left(next);
    let rest = pair_right(next);
    let combined = __str_concat(head, line);
    return pair(combined, rest);
}

fn first_line(tokens: String) -> String {
    let split = split_line(tokens);
    return pair_left(split);
}

fn rest_lines(tokens: String) -> String {
    let split = split_line(tokens);
    return pair_right(split);
}

fn token_is_keyword(tokens: String, keyword: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    let expected = __str_concat("Keyword ", keyword);
    return __str_eq(line, expected);
}

fn token_is_ident(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    return __str_starts_with(line, "Ident ");
}

fn token_is_number(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    return __str_starts_with(line, "Number ");
}

fn token_is_string(tokens: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    return __str_starts_with(line, "StringLiteral ");
}

fn token_is_punct(tokens: String, ch: String) -> Bool {
    if __str_is_empty(tokens) {
        return false;
    }
    let line = first_line(tokens);
    let expected = __str_concat("Punct ", ch);
    return __str_eq(line, expected);
}

fn token_rest(tokens: String) -> String {
    return rest_lines(tokens);
}

fn take_ident(tokens: String) -> String {
    let line = first_line(tokens);
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "Ident ");
    return pair(text, rest);
}

fn take_number(tokens: String) -> String {
    let line = first_line(tokens);
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "Number ");
    return pair(text, rest);
}

fn take_string_literal(tokens: String) -> String {
    let line = first_line(tokens);
    let rest = rest_lines(tokens);
    let text = __str_strip_prefix(line, "StringLiteral ");
    return pair(text, rest);
}

fn consume_keyword(tokens: String, keyword: String) -> String {
    if token_is_keyword(tokens, keyword) {
        return rest_lines(tokens);
    }
    return tokens;
}

fn consume_punct(tokens: String, ch: String) -> String {
    if token_is_punct(tokens, ch) {
        return rest_lines(tokens);
    }
    return tokens;
}

fn lex_tokens(source: String) -> String {
    return __lex_tokens(source);
}
