fn lex(source: String) -> String {
    return lex_tokens(source);
}

fn lex_tokens(source: String) -> String {
    let raw = __lex_tokens(source);
    return escape_tokens(raw);
}

fn skip_trivia(source: String) -> String {
    if __str_is_empty(source) {
        return source;
    }

    let whitespace = __str_take_whitespace(source);
    if __str_is_empty(whitespace) {
    } else {
        let rest = __str_strip_prefix(source, whitespace);
        return skip_trivia(rest);
    }

    if __str_starts_with(source, "//") {
        let comment = __str_take_line_comment(source);
        let rest = __str_strip_prefix(source, comment);
        return skip_trivia(rest);
    }

    if __str_starts_with(source, "/*") {
        let comment = __str_take_block_comment(source);
        let rest = __str_strip_prefix(source, comment);
        return skip_trivia(rest);
    }

    return source;
}

fn token_line(kind: String, text: String) -> String {
    let escaped = escape(text);
    let prefix = __str_concat(kind, " ");
    return __str_concat(prefix, escaped);
}

fn keyword_or_ident_line(ident: String) -> String {
    let escaped = escape(ident);
    if is_keyword(ident) {
        return __str_concat("Keyword ", escaped);
    }
    return __str_concat("Ident ", escaped);
}

fn is_keyword(text: String) -> Bool {
    if __str_eq(text, "effects") {
        return true;
    }
    if __str_eq(text, "requires") {
        return true;
    }
    if __str_eq(text, "fn") {
        return true;
    }
    if __str_eq(text, "workflow") {
        return true;
    }
    if __str_eq(text, "type") {
        return true;
    }
    if __str_eq(text, "record") {
        return true;
    }
    if __str_eq(text, "enum") {
        return true;
    }
    if __str_eq(text, "let") {
        return true;
    }
    if __str_eq(text, "if") {
        return true;
    }
    if __str_eq(text, "else") {
        return true;
    }
    if __str_eq(text, "match") {
        return true;
    }
    if __str_eq(text, "loop") {
        return true;
    }
    if __str_eq(text, "return") {
        return true;
    }
    if __str_eq(text, "step") {
        return true;
    }
    if __str_eq(text, "pre") {
        return true;
    }
    if __str_eq(text, "post") {
        return true;
    }
    if __str_eq(text, "invariant") {
        return true;
    }
    if __str_eq(text, "unsafe") {
        return true;
    }
    return false;
}

fn join_lines(head: String, tail: String) -> String {
    if __str_is_empty(tail) {
        return head;
    }
    let with_newline = __str_concat(head, "\n");
    return __str_concat(with_newline, tail);
}

fn escape_tokens(tokens: String) -> String {
    if __str_is_empty(tokens) {
        return "";
    }
    let split = split_line(tokens);
    let line = pair_left(split);
    let rest = pair_right(split);
    let escaped_line = escape_token_line(line);
    let tail = escape_tokens(rest);
    return join_lines(escaped_line, tail);
}

fn escape_token_line(line: String) -> String {
    if __str_starts_with(line, "Keyword ") {
        return escape_line_with_prefix("Keyword ", line);
    }
    if __str_starts_with(line, "Ident ") {
        return escape_line_with_prefix("Ident ", line);
    }
    if __str_starts_with(line, "Number ") {
        return escape_line_with_prefix("Number ", line);
    }
    if __str_starts_with(line, "StringLiteral ") {
        return escape_line_with_prefix("StringLiteral ", line);
    }
    if __str_starts_with(line, "Other ") {
        return escape_line_with_prefix("Other ", line);
    }
    return line;
}

fn escape_line_with_prefix(prefix: String, line: String) -> String {
    let rest = __str_strip_prefix(line, prefix);
    let escaped = escape(rest);
    return __str_concat(prefix, escaped);
}

fn escape(text: String) -> String {
    if __str_is_empty(text) {
        return "";
    }
    let head = __str_head(text);
    let tail = __str_tail(text);
    let escaped = escape_char(head);
    let rest = escape(tail);
    return __str_concat(escaped, rest);
}

fn escape_char(ch: String) -> String {
    if __str_eq(ch, "\\") {
        return "\\\\";
    }
    if __str_eq(ch, "\n") {
        return "\\n";
    }
    if __str_eq(ch, "\r") {
        return "\\r";
    }
    if __str_eq(ch, "\t") {
        return "\\t";
    }
    return ch;
}

fn split_line(value: String) -> String {
    if __str_is_empty(value) {
        return pair("", "");
    }
    let head = __str_head(value);
    if __str_eq(head, "\n") {
        let rest = __str_tail(value);
        return pair("", rest);
    }
    let next = split_line(__str_tail(value));
    let line = pair_left(next);
    let rest = pair_right(next);
    let combined = __str_concat(head, line);
    return pair(combined, rest);
}

fn pair(left: String, right: String) -> String {
    let sep = "\n<SEP>\n";
    let combined = __str_concat(left, sep);
    return __str_concat(combined, right);
}

fn pair_left(value: String) -> String {
    return __pair_left(value);
}

fn pair_right(value: String) -> String {
    return __pair_right(value);
}
