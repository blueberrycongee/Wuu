fn lex(source: String) -> String {
    return lex_tokens(source);
}

fn lex_pure(source: String) -> String {
    let raw = lex_tokens_pure(source);
    return escape_tokens(raw);
}

fn lex_tokens(source: String) -> String {
    if is_bounded(source, lex_limit()) {
        let raw = lex_tokens_pure(source);
        return escape_tokens(raw);
    }
    let raw = __lex_tokens(source);
    return escape_tokens(raw);
}

fn lex_tokens_pure(source: String) -> String {
    let rest = skip_trivia(source);
    if __str_is_empty(rest) {
        return "";
    }
    let head = __str_head(rest);
    if __str_is_ident_start(head) {
        let ident = __str_take_ident(rest);
        let tail = __str_strip_prefix(rest, ident);
        let line = keyword_or_ident_line_raw(ident);
        let next = lex_tokens_pure(tail);
        return join_lines(line, next);
    }
    if __str_is_digit(head) {
        let number = __str_take_number(rest);
        let tail = __str_strip_prefix(rest, number);
        let line = token_line_raw("Number", number);
        let next = lex_tokens_pure(tail);
        return join_lines(line, next);
    }
    if __str_eq(head, "\"") {
        let literal = __str_take_string_literal(rest);
        let tail = __str_strip_prefix(rest, literal);
        let line = token_line_raw("StringLiteral", literal);
        let next = lex_tokens_pure(tail);
        return join_lines(line, next);
    }
    if __str_is_ascii(head) {
        let line = __str_concat("Punct ", head);
        let tail = __str_tail(rest);
        let next = lex_tokens_pure(tail);
        return join_lines(line, next);
    }
    let line = token_line_raw("Other", head);
    let tail = __str_tail(rest);
    let next = lex_tokens_pure(tail);
    return join_lines(line, next);
}

fn is_bounded(source: String, limit: String) -> Bool {
    if __str_is_empty(source) {
        return true;
    }
    if __str_is_empty(limit) {
        return false;
    }
    let next_source = __str_tail(source);
    let next_limit = __str_tail(limit);
    return is_bounded(next_source, next_limit);
}

fn lex_limit() -> String {
    let chunk = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
    let chunk = __str_concat(chunk, chunk);
    let chunk = __str_concat(chunk, chunk);
    let chunk = __str_concat(chunk, chunk);
    let chunk = __str_concat(chunk, chunk);
    let chunk = __str_concat(chunk, chunk);
    return chunk;
}

fn skip_trivia(source: String) -> String {
    if __str_is_empty(source) {
        return source;
    }

    let whitespace = __str_take_whitespace(source);
    if __str_is_empty(whitespace) {
    } else {
        let rest = __str_strip_prefix(source, whitespace);
        return skip_trivia(rest);
    }

    if __str_starts_with(source, "//") {
        let comment = __str_take_line_comment(source);
        let rest = __str_strip_prefix(source, comment);
        return skip_trivia(rest);
    }

    if __str_starts_with(source, "/*") {
        let comment = __str_take_block_comment(source);
        let rest = __str_strip_prefix(source, comment);
        return skip_trivia(rest);
    }

    return source;
}

fn token_line(kind: String, text: String) -> String {
    let escaped = escape(text);
    let prefix = __str_concat(kind, " ");
    return __str_concat(prefix, escaped);
}

fn keyword_or_ident_line(ident: String) -> String {
    let escaped = escape(ident);
    if is_keyword(ident) {
        return __str_concat("Keyword ", escaped);
    }
    return __str_concat("Ident ", escaped);
}

fn token_line_raw(kind: String, text: String) -> String {
    let prefix = __str_concat(kind, " ");
    return __str_concat(prefix, text);
}

fn keyword_or_ident_line_raw(ident: String) -> String {
    if is_keyword(ident) {
        return __str_concat("Keyword ", ident);
    }
    return __str_concat("Ident ", ident);
}

fn is_keyword(text: String) -> Bool {
    if __str_eq(text, "effects") {
        return true;
    }
    if __str_eq(text, "requires") {
        return true;
    }
    if __str_eq(text, "fn") {
        return true;
    }
    if __str_eq(text, "workflow") {
        return true;
    }
    if __str_eq(text, "type") {
        return true;
    }
    if __str_eq(text, "record") {
        return true;
    }
    if __str_eq(text, "enum") {
        return true;
    }
    if __str_eq(text, "let") {
        return true;
    }
    if __str_eq(text, "if") {
        return true;
    }
    if __str_eq(text, "else") {
        return true;
    }
    if __str_eq(text, "match") {
        return true;
    }
    if __str_eq(text, "loop") {
        return true;
    }
    if __str_eq(text, "return") {
        return true;
    }
    if __str_eq(text, "step") {
        return true;
    }
    if __str_eq(text, "pre") {
        return true;
    }
    if __str_eq(text, "post") {
        return true;
    }
    if __str_eq(text, "invariant") {
        return true;
    }
    if __str_eq(text, "unsafe") {
        return true;
    }
    return false;
}

fn escape_tokens(tokens: String) -> String {
    if __str_is_empty(tokens) {
        return "";
    }
    let split = split_line(tokens);
    let line = pair_left(split);
    let rest = pair_right(split);
    let escaped_line = escape_token_line(line);
    let tail = escape_tokens(rest);
    return join_lines(escaped_line, tail);
}

fn escape_token_line(line: String) -> String {
    if __str_starts_with(line, "Keyword ") {
        return escape_line_with_prefix("Keyword ", line);
    }
    if __str_starts_with(line, "Ident ") {
        return escape_line_with_prefix("Ident ", line);
    }
    if __str_starts_with(line, "Number ") {
        return escape_line_with_prefix("Number ", line);
    }
    if __str_starts_with(line, "StringLiteral ") {
        return escape_line_with_prefix("StringLiteral ", line);
    }
    if __str_starts_with(line, "Other ") {
        return escape_line_with_prefix("Other ", line);
    }
    return line;
}

fn escape_line_with_prefix(prefix: String, line: String) -> String {
    let rest = __str_strip_prefix(line, prefix);
    let escaped = escape(rest);
    return __str_concat(prefix, escaped);
}
