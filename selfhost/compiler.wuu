fn compile_module(ast: String) -> String {
    if __str_is_empty(ast) {
        return "";
    }
    if __str_eq(node_tag(ast), "Module") {
        let items = node_payload(ast);
        return compile_items(items);
    }
    return "";
}

fn compile_items(items: String) -> String {
    if list_is_empty(items) {
        return "";
    }
    let head = list_head(items);
    let tail = list_tail(items);
    let head_code = compile_item(head);
    if list_is_empty(tail) {
        return head_code;
    }
    if __str_eq(tail, items) {
        return head_code;
    }
    let tail_code = compile_items(tail);
    return join_non_empty(head_code, tail_code);
}

fn compile_item(item: String) -> String {
    let tag = node_tag(item);
    if __str_eq(tag, "ItemFn") {
        return compile_fn(item);
    }
    if __str_eq(tag, "ItemWorkflow") {
        return compile_fn(item);
    }
    return "";
}

fn compile_fn(item: String) -> String {
    let payload = node_payload(item);
    let name = ast_left_value(payload);
    let rest1 = ast_right(payload);
    let params = ast_left(rest1);
    let rest2 = ast_right(rest1);
    let _ret = ast_left(rest2);
    let rest3 = ast_right(rest2);
    let _effects_opt = ast_left(rest3);
    let rest4 = ast_right(rest3);
    let _contracts = ast_left(rest4);
    let block = ast_right(rest4);

    let header = __str_concat("fn ", name);
    let param_lines = compile_params(params);
    let body = compile_block(block);
    let with_params = join_non_empty(header, param_lines);
    let with_body = join_non_empty(with_params, body);
    return join_lines(with_body, "end");
}

fn compile_params(params: String) -> String {
    if list_is_empty(params) {
        return "";
    }
    let head = list_head(params);
    let tail = list_tail(params);
    let head_line = compile_param(head);
    if list_is_empty(tail) {
        return head_line;
    }
    if __str_eq(tail, params) {
        return head_line;
    }
    let tail_lines = compile_params(tail);
    return join_non_empty(head_line, tail_lines);
}

fn compile_param(param: String) -> String {
    let payload = node_payload(param);
    let name = ast_left_value(payload);
    return __str_concat("param ", name);
}

fn compile_block(block: String) -> String {
    let stmts = node_payload(block);
    return compile_stmt_list(stmts);
}

fn compile_stmt_list(stmts: String) -> String {
    if list_is_empty(stmts) {
        return "";
    }
    let head = list_head(stmts);
    let tail = list_tail(stmts);
    let head_code = compile_stmt(head);
    if list_is_empty(tail) {
        return head_code;
    }
    if __str_eq(tail, stmts) {
        return head_code;
    }
    let tail_code = compile_stmt_list(tail);
    return join_non_empty(head_code, tail_code);
}

fn compile_stmt(stmt: String) -> String {
    let tag = node_tag(stmt);
    if __str_eq(tag, "StmtLet") {
        let payload = node_payload(stmt);
        let name = ast_left_value(payload);
        let rest = ast_right(payload);
        let _ty = ast_left(rest);
        let expr = ast_right(rest);
        let expr_code = compile_expr(expr);
        let store_line = __str_concat("store ", name);
        return join_lines(expr_code, store_line);
    }
    if __str_eq(tag, "StmtLoop") {
        return compile_loop(stmt);
    }
    if __str_eq(tag, "StmtStep") {
        return compile_step(stmt);
    }
    if __str_eq(tag, "StmtIf") {
        return compile_if(stmt);
    }
    if __str_eq(tag, "StmtReturn") {
        let expr_opt = node_payload(stmt);
        return compile_return(expr_opt);
    }
    if __str_eq(tag, "StmtExpr") {
        let expr = node_payload(stmt);
        let expr_code = compile_expr(expr);
        return join_lines(expr_code, "pop");
    }
    return "";
}

fn compile_return(expr_opt: String) -> String {
    if option_is_none(expr_opt) {
        return join_lines("const_unit", "return");
    }
    let expr = option_unwrap(expr_opt);
    let expr_code = compile_expr(expr);
    return join_lines(expr_code, "return");
}

fn compile_expr(expr: String) -> String {
    let tag = node_tag(expr);
    if __str_eq(tag, "ExprNumber") {
        let text = ast_unescape(node_payload(expr));
        return __str_concat("const_int ", text);
    }
    if __str_eq(tag, "ExprBool") {
        let text = ast_unescape(node_payload(expr));
        return __str_concat("const_bool ", text);
    }
    if __str_eq(tag, "ExprString") {
        let text = ast_unescape(node_payload(expr));
        let raw = unquote_literal(text);
        let encoded = encode_string(raw);
        return __str_concat("const_string ", encoded);
    }
    if __str_eq(tag, "ExprPath") {
        let path = node_payload(expr);
        let name = path_single_name(path);
        if __str_is_empty(name) {
            return "";
        }
        return __str_concat("load ", name);
    }
    if __str_eq(tag, "ExprCall") {
        let payload = node_payload(expr);
        let path = ast_left(payload);
        let args = ast_right(payload);
        let args_code = compile_call_args(args);
        let name = path_single_name(path);
        if __str_is_empty(name) {
            return "";
        }
        let argc = count_list(args);
        let call_line = compile_call_line(name, argc);
        return join_non_empty(args_code, call_line);
    }
    return "";
}

fn compile_if(stmt: String) -> String {
    let payload = node_payload(stmt);
    let cond = ast_left(payload);
    let rest = ast_right(payload);
    let then_block = ast_left(rest);
    let else_opt = ast_right(rest);

    let span = node_span(stmt);
    let else_label = make_label(span, "else");
    let end_label = make_label(span, "end");

    let cond_code = compile_expr(cond);
    let then_code = compile_block(then_block);
    if option_is_none(else_opt) {
        let jump_line = __str_concat("jump_if_false ", end_label);
        let with_jump = join_non_empty(cond_code, jump_line);
        let with_then = join_non_empty(with_jump, then_code);
        let label_line = __str_concat("label ", end_label);
        return join_non_empty(with_then, label_line);
    }

    let else_block = option_unwrap(else_opt);
    let else_code = compile_block(else_block);
    let jump_else = __str_concat("jump_if_false ", else_label);
    let after_cond = join_non_empty(cond_code, jump_else);
    let after_then = join_non_empty(after_cond, then_code);
    let jump_end = __str_concat("jump ", end_label);
    let after_jump_end = join_non_empty(after_then, jump_end);
    let label_else = __str_concat("label ", else_label);
    let after_label_else = join_non_empty(after_jump_end, label_else);
    let after_else = join_non_empty(after_label_else, else_code);
    let label_end = __str_concat("label ", end_label);
    return join_non_empty(after_else, label_end);
}

fn compile_loop(stmt: String) -> String {
    let block = node_payload(stmt);
    let span = node_span(stmt);
    let start_label = make_loop_label(span);
    let label_line = __str_concat("label ", start_label);
    let body_code = compile_block(block);
    let jump_line = __str_concat("jump ", start_label);
    let with_body = join_non_empty(label_line, body_code);
    return join_non_empty(with_body, jump_line);
}

fn compile_step(stmt: String) -> String {
    let payload = node_payload(stmt);
    let block = ast_right(payload);
    return compile_block(block);
}

fn compile_call_args(args: String) -> String {
    if list_is_empty(args) {
        return "";
    }
    let head = list_head(args);
    let tail = list_tail(args);
    let head_expr = compile_expr(head);
    if __str_is_empty(head_expr) {
        return "";
    }
    let head_with_arg = head_expr;
    if list_is_empty(tail) {
        return head_with_arg;
    }
    if __str_eq(tail, args) {
        return head_with_arg;
    }
    let tail_code = compile_call_args(tail);
    return join_non_empty(head_with_arg, tail_code);
}

fn compile_call_line(name: String, argc: String) -> String {
    if __str_starts_with(name, "__") {
        let prefix = __str_concat("call_builtin ", name);
        let prefix = __str_concat(prefix, " ");
        return __str_concat(prefix, argc);
    }
    let prefix = __str_concat("call ", name);
    let prefix = __str_concat(prefix, " ");
    return __str_concat(prefix, argc);
}

fn path_single_name(path: String) -> String {
    let segments = node_payload(path);
    if list_is_empty(segments) {
        return "";
    }
    let head = ast_unescape(list_head(segments));
    let tail = list_tail(segments);
    if list_is_empty(tail) {
        return head;
    }
    if __str_eq(tail, segments) {
        return head;
    }
    return "";
}

fn count_list(list: String) -> String {
    if list_is_empty(list) {
        return "0";
    }
    let tail = list_tail(list);
    let rest = count_list(tail);
    return inc_decimal(rest);
}

fn inc_decimal(text: String) -> String {
    if __str_is_empty(text) {
        return "1";
    }
    let last = last_char(text);
    let prefix = strip_last_char(text);
    if __str_eq(last, "0") {
        return __str_concat(prefix, "1");
    }
    if __str_eq(last, "1") {
        return __str_concat(prefix, "2");
    }
    if __str_eq(last, "2") {
        return __str_concat(prefix, "3");
    }
    if __str_eq(last, "3") {
        return __str_concat(prefix, "4");
    }
    if __str_eq(last, "4") {
        return __str_concat(prefix, "5");
    }
    if __str_eq(last, "5") {
        return __str_concat(prefix, "6");
    }
    if __str_eq(last, "6") {
        return __str_concat(prefix, "7");
    }
    if __str_eq(last, "7") {
        return __str_concat(prefix, "8");
    }
    if __str_eq(last, "8") {
        return __str_concat(prefix, "9");
    }
    if __str_eq(last, "9") {
        let next = inc_decimal(prefix);
        return __str_concat(next, "0");
    }
    return __str_concat(prefix, last);
}

fn last_char(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    let head = __str_head(value);
    let tail = __str_tail(value);
    if __str_is_empty(tail) {
        return head;
    }
    return last_char(tail);
}

fn node_span(node: String) -> String {
    let tag_span = ast_left_value(node);
    let split = split_at_char(tag_span, "@");
    return pair_right(split);
}

fn make_label(span: String, suffix: String) -> String {
    if __str_is_empty(span) {
        let base = __str_concat("if_", suffix);
        return __str_concat(base, "_0");
    }
    let base = __str_concat("if_", span);
    let base = __str_concat(base, "_");
    return __str_concat(base, suffix);
}

fn make_loop_label(span: String) -> String {
    if __str_is_empty(span) {
        return "loop_0";
    }
    let base = __str_concat("loop_", span);
    return __str_concat(base, "_start");
}

fn unquote_literal(text: String) -> String {
    let inner = strip_first_char(text);
    let inner = strip_last_char(inner);
    return unescape_string(inner);
}

fn strip_first_char(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    return __str_tail(value);
}

fn strip_last_char(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    let head = __str_head(value);
    let tail = __str_tail(value);
    if __str_is_empty(tail) {
        return "";
    }
    let rest = strip_last_char(tail);
    return __str_concat(head, rest);
}

fn unescape_string(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    let head = __str_head(value);
    let tail = __str_tail(value);
    if __str_eq(head, "\\") {
        if __str_is_empty(tail) {
            return "";
        }
        let esc = __str_head(tail);
        let rest = __str_tail(tail);
        let decoded = decode_escape(esc);
        let next = unescape_string(rest);
        return __str_concat(decoded, next);
    }
    let next = unescape_string(tail);
    return __str_concat(head, next);
}

fn decode_escape(ch: String) -> String {
    if __str_eq(ch, "n") {
        return "\n";
    }
    if __str_eq(ch, "r") {
        return "\r";
    }
    if __str_eq(ch, "t") {
        return "\t";
    }
    if __str_eq(ch, "\\") {
        return "\\";
    }
    if __str_eq(ch, "\"") {
        return "\"";
    }
    return ch;
}

fn encode_string(value: String) -> String {
    if __str_is_empty(value) {
        return "";
    }
    let head = __str_head(value);
    let tail = __str_tail(value);
    let encoded = encode_char(head);
    let rest = encode_string(tail);
    return __str_concat(encoded, rest);
}

fn encode_char(ch: String) -> String {
    if __str_eq(ch, "\\") {
        return "\\\\";
    }
    if __str_eq(ch, "\n") {
        return "\\n";
    }
    if __str_eq(ch, "\r") {
        return "\\r";
    }
    if __str_eq(ch, "\t") {
        return "\\t";
    }
    if __str_eq(ch, "\"") {
        return "\\\"";
    }
    return ch;
}

fn join_non_empty(head: String, tail: String) -> String {
    if __str_is_empty(head) {
        return tail;
    }
    if __str_is_empty(tail) {
        return head;
    }
    return join_lines(head, tail);
}
